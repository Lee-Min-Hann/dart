ÅqhandleUnescapeErrorurilogEventbeginArgumentsendArgumentshandleObjectPatternFieldshandleAsyncModifierbeginAwaitExpressionendAwaitExpressionendInvalidAwaitExpression
beginBlockendBlockhandleInvalidTopLevelBlockbeginCascade
endCascadebeginCaseExpressionendCaseExpression beginClassOrMixinOrExtensionBodyendClassOrMixinOrExtensionBody/beginClassOrMixinOrNamedMixinApplicationPreludebeginClassDeclarationhandleClassExtendshandleImplementshandleClassHeaderhandleRecoverDeclarationHeaderendClassDeclarationbeginMixinDeclarationhandleMixinOnhandleMixinHeaderhandleRecoverMixinHeaderendMixinDeclaration%beginUncategorizedTopLevelDeclaration beginExtensionDeclarationPreludebeginExtensionDeclarationendExtensionDeclarationbeginExtensionTypeDeclarationendExtensionTypeDeclarationbeginPrimaryConstructorendPrimaryConstructorhandleNoPrimaryConstructorbeginCombinatorsendCombinatorsbeginCompilationUnithandleDirectivesOnlyendCompilationUnitbeginConstLiteralendConstLiteralbeginConstructorReferenceendConstructorReferencebeginDoWhileStatementendDoWhileStatementbeginDoWhileStatementBodyendDoWhileStatementBodybeginWhileStatementBodyendWhileStatementBody	beginEnumendEnumendEnumConstructorhandleEnumElementshandleEnumHeaderhandleEnumElementendEnumFactoryMethodbeginExport	endExporthandleExtraneousExpressionhandleExpressionStatementbeginFactoryMethodendClassFactoryMethodendMixinFactoryMethodendExtensionFactoryMethodendExtensionTypeFactoryMethodbeginFormalParameterendFormalParameterhandleNoFormalParametersbeginFormalParametersendFormalParametersendClassFieldsendMixinFieldsendExtensionFieldsendExtensionTypeFieldsendEnumFieldsendEnumMethod"handleForInitializerEmptyStatement'handleForInitializerExpressionStatement,handleForInitializerLocalVariableDeclaration-handleForInitializerPatternVariableAssignmentbeginForStatementhandleForLoopPartsendForStatementbeginForStatementBodyendForStatementBodyhandleForInLoopPartsendForInbeginForInExpressionendForInExpressionbeginForInBodyendForInBodybeginNamedFunctionExpressionendNamedFunctionExpressionbeginLocalFunctionDeclarationendLocalFunctionDeclarationbeginBlockFunctionBodyendBlockFunctionBodyhandleNoFunctionBodyhandleFunctionBodySkippedbeginFunctionNameendFunctionNamebeginTypedef
endTypedefhandleClassWithClausehandleClassNoWithClausehandleEnumWithClausehandleEnumNoWithClausehandleMixinWithClausebeginNamedMixinApplication%handleNamedMixinApplicationWithClauseendNamedMixinApplication	beginHideendHidehandleIdentifierListbeginTypeListendTypeListbeginIfStatementendIfStatementbeginThenStatementendThenStatementbeginElseStatementendElseStatementbeginImporthandleImportPrefix	endImporthandleRecoverImportbeginConditionalUrisendConditionalUrisbeginConditionalUriendConditionalUrihandleDottedNamebeginImplicitCreationExpressionendImplicitCreationExpressionbeginInitializedIdentifierendInitializedIdentifierbeginFieldInitializerendFieldInitializerhandleNoFieldInitializerbeginVariableInitializerendVariableInitializerhandleNoVariableInitializerbeginInitializerendInitializerbeginInitializersendInitializershandleNoInitializershandleInvalidExpressionhandleInvalidFunctionBodyhandleInvalidTypeReferencehandleLabelbeginLabeledStatementendLabeledStatementbeginLibraryAugmentationendLibraryAugmentationbeginLibraryNameendLibraryNamehandleLiteralMapEntryhandleMapPatternEntrybeginLiteralStringhandleInterpolationExpressionendLiteralStringhandleStringJuxtapositionbeginMemberhandleInvalidMember	endMemberbeginMethodendClassMethodendMixinMethodendExtensionMethodendExtensionTypeMethodendClassConstructorendMixinConstructorendExtensionConstructorendExtensionTypeConstructorbeginMetadataStarendMetadataStarbeginMetadataendMetadatabeginOptionalFormalParametersendOptionalFormalParameters	beginPartendPartbeginPartOf	endPartOfbeginRedirectingFactoryBodyendRedirectingFactoryBodybeginReturnStatementhandleNativeFunctionBodyhandleNativeFunctionBodyIgnoredhandleNativeFunctionBodySkippedhandleEmptyFunctionBodyhandleExpressionFunctionBodyendReturnStatement
handleSend	beginShowendShowbeginSwitchStatementendSwitchStatementbeginSwitchExpressionendSwitchExpressionbeginSwitchBlockendSwitchBlockbeginSwitchExpressionBlockendSwitchExpressionBlockbeginLiteralSymbolendLiteralSymbolhandleThrowExpressionbeginRethrowStatementendRethrowStatementendTopLevelDeclaration handleInvalidTopLevelDeclarationbeginTopLevelMemberbeginFieldsendTopLevelFieldsbeginTopLevelMethodendTopLevelMethodbeginTryStatementbeginCatchClauseendCatchClausehandleCatchBlockhandleFinallyBlockendTryStatement
handleTypehandleNonNullAssertExpressionhandleNullAssertPatternhandleNullCheckPatternhandleAssignedVariablePatternhandleDeclaredVariablePatternhandleWildcardPatternhandleNoNamebeginRecordTypeendRecordTypebeginRecordTypeEntryendRecordTypeEntrybeginRecordTypeNamedFieldsendRecordTypeNamedFieldsbeginFunctionTypeendFunctionTypebeginTypeArgumentsendTypeArgumentshandleInvalidTypeArgumentshandleNoTypeArgumentsbeginTypeVariablehandleTypeVariablesDefinedendTypeVariablebeginTypeVariablesendTypeVariables reportVarianceModifierNotEnabledbeginFunctionExpressionendFunctionExpressionbeginVariablesDeclarationendVariablesDeclarationbeginWhileStatementendWhileStatementbeginAsOperatorTypeendAsOperatorTypehandleAsOperatorhandleCastPatternhandleAssignmentExpressionbeginBinaryExpressionendBinaryExpressionbeginBinaryPatternendBinaryPatternhandleEndingBinaryExpressionbeginConditionalExpression handleConditionalExpressionColonendConditionalExpressionbeginConstExpressionendConstExpressionhandleConstFactorybeginForControlFlowendForControlFlowendForInControlFlowbeginIfControlFlowhandleThenControlFlowhandleElseControlFlowendIfControlFlowendIfElseControlFlowhandleSpreadExpressionhandleRestPattern!beginFunctionTypedFormalParameterendFunctionTypedFormalParameterhandleIdentifierhandleIndexedExpressionbeginIsOperatorTypeendIsOperatorTypehandleIsOperatorhandleLiteralBoolhandleBreakStatementhandleContinueStatementhandleEmptyStatementbeginAssert	endAsserthandleLiteralDoublehandleLiteralInthandleLiteralListhandleListPatternhandleLiteralSetOrMaphandleMapPatternhandleLiteralNullhandleNativeClausehandleNamedArgumenthandlePatternFieldhandleNamedRecordFieldbeginNewExpressionendNewExpressionhandleNoArguments:handleNoConstructorReferenceContinuationAfterTypeArguments&handleNoTypeNameInConstructorReferencehandleNoTypehandleNoTypeVariableshandleOperatorhandleSwitchCaseNoWhenClause!handleSwitchExpressionCasePatternhandleSymbolVoidhandleOperatorNamehandleInvalidOperatorNamehandleParenthesizedConditionbeginPatternbeginPatternGuard+beginParenthesizedExpressionOrRecordLiteralbeginSwitchCaseWhenClauseendRecordLiteralhandleRecordPattern
endPatternendPatternGuardendParenthesizedExpressionendSwitchCaseWhenClausehandleParenthesizedPatternbeginConstantPatternendConstantPatternhandleObjectPatternhandleQualifiedhandleStringParthandleSuperExpressionhandleAugmentSuperExpressionbeginSwitchCaseendSwitchCasebeginSwitchExpressionCaseendSwitchExpressionCasehandleThisExpression&handleUnaryPostfixAssignmentExpressionhandleUnaryPrefixExpressionhandleRelationalPattern%handleUnaryPrefixAssignmentExpression*beginFormalParameterDefaultValueExpression(endFormalParameterDefaultValueExpressionhandleValuedFormalParameter!handleFormalParameterWithoutValuehandleVoidKeyword"handleVoidKeywordWithTypeArgumentsbeginYieldStatementendYieldStatementendInvalidYieldStatementhandleRecoverableErrorhandleExperimentNotEnabledhandleErrorTokenhandleInvalidStatementhandleScripthandleTypeArgumentApplicationhandleNewAsIdentifier)handlePatternVariableDeclarationStatementhandlePatternAssignmentUnescapeErrorListenerListener_fe_analyzer_sharedparserlistenerMessageMessageCodeToken
ErrorTokenAssert	BlockKindConstructorReferenceContextFormalParameterKindIdentifierContextDeclarationHeaderKindDeclarationKind
MemberKindvoidintUriStringboolparseDirectivesParserinAssignmentPatternExperimentalFlagvariancegetExperimentNotEnabledMessageassertionMessageoverrideUnescapeErrorListeneróbL=†æ¬ù◊qG…v    Å  ../experiments/errors.dart  Å-  ../experiments/flags.dartÅpÅâMessageMessageCode ÅQ  ../messages/codes.dartÅ´ÅµToken Åç  ../scanner/token.dartÅ›ÅÏ
ErrorToken Åπ  ../scanner/error_token.dartÇÇAssert Å  assert.dartÇ+Ç9	BlockKind Ç  block_kind.dartÇhÇàConstructorReferenceContext Ç=  "constructor_reference_context.dartÇØÇ«FormalParameterKind Çå  formal_parameter_kind.dartÇÎÉIdentifierContext ÇÀ  identifier_context.dartÉ#ÉNDeclarationHeaderKindDeclarationKind É  declaration_kind.dartÉkÉz
MemberKind ÉR  member_kind.dart    	dart:core¿ ‘˙ ¿#Ëâ NÄúÄÿÄŸÅÅÅ,ÅPÅãÅåÅ∑Å∏ÅÓÅÔÇÇÇ;Ç<ÇäÇãÇ…Ç ÉÉÉPÉQÉ|É}É§É¿ÑÑÑÑMÑcÑgÑ≥Ñ∑Ñ˝ÖMÖcÖgÖ∂Ö¡ÖÛÜÜÜ,Ü-ÜSÜTÜóÜ≤Ü∂Ü∑áá1áÅá¶á™á´á„à%àDàHàIàîà¿à¡à¸ââXâyâ}â~âπâ◊â˘ä:äbäfägäûäüä∞ä˙ãããã`ãûã¨ãﬁãﬂåååå3å7å8åiåjå≤å“å÷å◊ç%çpç~çÃçÕéébéhé•éÃèèJèNèOèúèµèªêêEêcêiêíêŸê⁄ëëPëöë†ëÌííí:íSímíÖí¢íªí÷íÔìììKìzìÀîî&îhîÜîäîãî‘îÈïïLïhïlïmï≠ïæï–ï„ï˙ññ ñ:ñPñ†ñΩñ¡ñ¬ó
óLóäó≤óÊó¯òò&òjòîòòòôò÷òÎò˛ô=ô_ôcôdôóô€öööXörö™ö√ö«ö»õõõ,õCõTõnõùõ∫õæõøõıú7úuú∑úÍú˚ùù7ùKùoùìùóùòù’ùÍûûEûgûkûlû™û∞ûŸüüügüxü~üÃ†††H†ã†å†‹†Û†˘°F°h°´°¨°ˆ¢-¢=¢J¢ì¢Ω¢„¢Á¢Ë£5£L£R£ü£≈§	§
§T§è§≥§Õ§⁄•$•g•ë•ï•ñ•‚¶¶E¶i¶m¶n¶∏ßß$ß*ßZß`ßuß≤ß¬ß‡®(®L®P®Q®†®–©©©@©A©d©Å©Ö©Ü©≤©≥©Ï™3™9™™¿™—™Ú™Û´'´H´L´M´v´w´†´æ´¬´√´Ù´ı¨:¨ã¨±¨µ¨∂¨„¨‰≠ ≠=≠_≠c≠d≠ï≠ñ≠ƒ≠Í≠Ó≠ÔÆÆÆNÆrÆvÆwÆûÆüÆ‹Æ˘ØØTØ}ØìØóØòØ·ØÚ∞∞;∞R∞l∞Å∞ñ∞£∞Ú±$±d±x±¿±ƒ±≈±Ù≤≤*≤q≤è≤ì≤î≤‘≤Â≥≥≥/≥I≥b≥£≥ø≥√≥ƒ≥Ú¥¥#¥e¥Ç¥Ü¥á¥§¥‰µ%µ)µ*µMµNµãµúµ®µ¡µ’∂∂&∂*∂+∂t∂√∂Á∑)∑O∑S∑T∑Ñ∑©∑≠∑Æ∑Ë∏&∏u∏ß∏®∏∆ππ*π.π/πMπçπÕ∫∫∫∫5∫u∫µ∫ˆ∫˙∫˚ª!ªaª°ª‚ªÊªÁº7ºoºpºãº•º¿ºÂº¸ΩΩ8ΩXΩwΩòΩúΩùΩ›ææææDæEæaæßæ…æÕæŒøø"ø4øAømøsøìø™ø∆ø·ø˝¿ @¿ @4¿ @L¿ @j¿ @{¿ @ì¿ @´¿ @√¿ @«¿ @»¿ A¿ A¿ A.¿ A;¿ Ag¿ Am¿ Aç¿ A§¿ A¿¿ A€¿ A˜¿ B¿ B.¿ BF¿ Bd¿ Bu¿ Bç¿ B•¿ BÂ¿ B˘¿ C¿ C&¿ C=¿ CR¿ Cj¿ C}¿ Cñ¿ C•¿ Cπ¿ CÃ¿ C–¿ C—¿ D¿ D)¿ D;¿ DH¿ Dt¿ Dz¿ Dö¿ Dµ¿ D—¿ DÏ¿ E¿ E"¿ E?¿ EW¿ Eu¿ EÜ¿ Eû¿ E∂¿ Eˆ¿ F
¿ F!¿ F7¿ FN¿ Fc¿ F{¿ Fé¿ Fß¿ F∂¿ F ¿ F›¿ F·¿ F‚¿ G.¿ G?¿ GQ¿ G^¿ Gä¿ Gê¿ G∞¿ Gœ¿ GÎ¿ H¿ H"¿ H<¿ HY¿ Hq¿ Hè¿ H†¿ H∏¿ H–¿ I¿ I$¿ I;¿ IQ¿ Ih¿ I}¿ Iï¿ I®¿ I¡¿ I–¿ I‰¿ I˜¿ I˚¿ I¸¿ J?¿ JP¿ Jb¿ Jo¿ Jõ¿ J°¿ J¡¿ J◊¿ JÛ¿ K¿ K*¿ KD¿ Ka¿ Ky¿ Kó¿ K®¿ K¿¿ Kÿ¿ KÏ¿ L¿ L¿ L0¿ LE¿ L]¿ Lp¿ Lâ¿ Lò¿ L¨¿ Lø¿ L√¿ Lƒ¿ M¿ M¿ M-¿ Mb¿ My¿ Mì¿ M®¿ MΩ¿ M ¿ N¿ NF¿ NZ¿ N¢¿ N¶¿ Nß¿ N˜¿ O¿ OQ¿ O¿ OÉ¿ OÑ¿ O‘¿ O˙¿ PD¿ Pw¿ P{¿ P|¿ PÃ¿ Q¿ Q7¿ QÜ¿ Qæ¿ Q¬¿ Q√¿ R¿ RI¿ Rz¿ R∞¿ R’¿ S¿ S¿ S¿ S[¿ SÇ¿ S´¿ S¨¿ SÙ¿ TA¿ T¿ Tº¿ Tı¿ Tˆ¿ U¿ U=¿ UA¿ UB¿ Uo¿ Up¿ Uù¿ Uø¿ U√¿ Uƒ¿ V¿ V\¿ Vñ¿ VÕ¿ W¿ W<¿ Ww¿ W∂¿ W˛¿ Wˇ¿ XN¿ Xp¿ Xá¿ Xã¿ Xå¿ X∏¿ Xπ¿ X‚¿ Y¿ Y¿ Y¿ Y.¿ Y/¿ YU¿ Yp¿ Yt¿ Yu¿ Y¡¿ Z¿ Z_¿ Z•¿ Z´¿ Z¿¿ Z◊¿ [¿ [¿ [P¿ [ö¿ [Ê¿ \#¿ \)¿ \>¿ \U¿ \g¿ \{¿ \à¿ \ò¿ \≠¿ \ƒ¿ \˜¿ ]+¿ ]T¿ ]X¿ ]Y¿ ]•¿ ]∂¿ ]Õ¿ ^¿ ^¿ ^!¿ ^'¿ ^<¿ ^M¿ ^d¿ ^x¿ ^Ö¿ ^ú¿ ^¨¿ ^¡¿ ^ÿ¿ _¿ _@¿ _e¿ _i¿ _j¿ _≤¿ `¿ `P¿ `z¿ `®¿ `©¿ `ˆ¿ a?¿ aé¿ a‹¿ b#¿ bW¿ b¢¿ b≈¿ b…¿ b ¿ bı¿ c¿ c¿ c¿ cb¿ ch¿ c∂¿ c⁄¿ d"¿ d#¿ dL¿ dM¿ dÖ¿ d£¿ dß¿ d®¿ dÃ¿ dÕ¿ d¸¿ e¿ eG¿ eX¿ el¿ eÜ¿ e£¿ eΩ¿ e√¿ f¿ f¿ f8¿ fU¿ f{¿ f«¿ fﬂ¿ g¿ g¿ g¿ gG¿ g\¿ g{¿ g≠¿ gŒ¿ g“¿ g”¿ h¿ h'¿ hJ¿ hN¿ hO¿ hè¿ h§¿ h√¿ h…¿ i¿ iF¿ iw¿ ió¿ iõ¿ iú¿ iÕ¿ iÔ¿ j¿ j¿ j¿ jV¿ jk¿ jä¿ jê¿ j–¿ k¿ k8¿ kY¿ k]¿ k^¿ kó¿ kﬂ¿ l)¿ l/¿ l|¿ lü¿ l∑¿ l”¿ lÏ¿ m¿ m¿ m;¿ mT¿ mo¿ mà¿ mù¿ mû¿ mÁ¿ m¸¿ n¿ n-¿ no¿ n†¿ n§¿ n•¿ nË¿ n˘¿ o¿ o¿ o5¿ oG¿ o[¿ oÄ¿ oÜ¿ oŒ¿ p¿ pk¿ p´¿ p±¿ pÙ¿ qC¿ qu¿ qú¿ q†¿ q°¿ q»¿ q…¿ r¿ r,¿ rP¿ rf¿ rj¿ rk¿ rî¿ r¥¿ r∏¿ rπ¿ rﬁ¿ rﬂ¿ rˇ¿ s¿ s¿ s¿ sF¿ sG¿ sÄ¿ sù¿ s°¿ s¢¿ sÃ¿ sÕ¿ sÙ¿ t¿ t¿ t¿ tB¿ tC¿ tj¿ tâ¿ tç¿ té¿ tπ¿ t∫¿ u ¿ u?¿ uq¿ uß¿ uÌ¿ v¿ v¿ v¿ vM¿ v^¿ vj¿ vÉ¿ vù¿ v±¿ w ¿ w¿ w¿ w¿ wX¿ wí¿ w‘¿ x"¿ x;¿ xU¿ xi¿ xò¿ x∏¿ xº¿ xΩ¿ xÈ¿ xÍ¿ y¿ y2¿ y6¿ y7¿ yf¿ yg¿ y¨¿ y¿¿ z ¿ z¿ zl¿ zå¿ zê¿ zë¿ zÕ¿ zÈ¿ zÌ¿ zÓ¿ {%¿ {&¿ {r¿ {û¿ {¢¿ {£¿ {’¿ {÷¿ |	¿ |0¿ |4¿ |5¿ |b¿ |c¿ |†¿ |ø¿ |˛¿ } ¿ }$¿ }%¿ }S¿ }Ç¿ }¶¿ }™¿ }´¿ }€¿ }‹¿ ~¿ ~;¿ ~u¿ ~ö¿ ~û¿ ~ü¿ ~Œ¿  ¿ '¿ +¿ ,¿ T¿ U¿ }¿ •¿ ©¿ ™¿ ”¿ ‘¿ Ä¿ Ä8¿ Ä<¿ Ä=¿ Ä]¿ Ä}¿ ÄÅ¿ ÄÇ¿ Ä–¿ Å¿ ÅB¿ Åp¿ Åì¿ Åó¿ Åò¿ Åﬂ¿ Ç/¿ Çi¿ Çô¿ Çæ¿ Ç¬¿ Ç√¿ É¿ É\¿ Ék¿ Éú¿ É¬¿ É∆¿ É«¿ ÉÈ¿ Ñ ¿ Ñ¿ Ñ¿ ÑB¿ ÑC¿ Ñp¿ Ñí¿ Ññ¿ Ñó¿ ÑÊ¿ ÑÁ¿ Ö1¿ ÖB¿ ÖN¿ Öm¿ Ö≤¿ Ö◊¿ Ö€¿ Ö‹¿ Ü¿ Ü¿ ÜB¿ ÜS¿ ÜÅ¿ ÜŒ¿ ÜÎ¿ ÜÔ¿ Ü¿ á,¿ áM¿ áQ¿ áR¿ á°¿ áÀ¿ à¿ à(¿ à,¿ à-¿ àW¿ àX¿ à®¿ à©¿ àÎ¿ â
¿ â¿ â¿ âV¿ â{¿ â¿ âÄ¿ âœ¿ ä¿ äW¿ äz¿ äí¿ äì¿ äŒ¿ äﬂ¿ ã¿ ã+¿ ã/¿ ã0¿ ãk¿ ã®¿ ãæ¿ ã¿ å0¿ åp¿ å§¿ å–¿ åÂ¿ å˝¿ ç¿ ç¿ çQ¿ çb¿ çÆ¿ ç˛¿ é¿ é*¿ éQ¿ él¿ éà¿ é¢¿ éø¿ é›¿ éÙ¿ è	¿ è
¿ èN¿ è_¿ ès¿ è®¿ èø¿ èŸ¿ èÓ¿ ê¿ ê¿ ê[¿ êç¿ ê™¿ êÆ¿ êØ¿ êÛ¿ ë¿ ë¿ ëM¿ ëd¿ ë~¿ ëì¿ ë®¿ ëµ¿ í ¿ í2¿ ír¿ íÜ¿ íŒ¿ í“¿ í”¿ ì¿ ì,¿ ì@¿ ìu¿ ìå¿ ì¶¿ ìª¿ ì–¿ ì›¿ î,¿ î^¿ îû¿ î≤¿ î˙¿ î˛¿ îˇ¿ ïL¿ ï]¿ ïq¿ ï¶¿ ïΩ¿ ï◊¿ ïÏ¿ ñ¿ ñ¿ ñO¿ ñì¿ ñ”¿ ñÁ¿ ó/¿ ó3¿ ó4¿ ó}¿ óé¿ ó¢¿ ó◊¿ óÓ¿ ò¿ ò¿ ò2¿ ò?¿ òè¿ ò¡¿ ô¿ ô¿ ô]¿ ôa¿ ôb¿ ô´¿ ôº¿ ô–¿ ö¿ ö¿ ö6¿ öK¿ ö`¿ öm¿ öΩ¿ öÔ¿ õ/¿ õC¿ õã¿ õè¿ õê¿ õ›¿ õÓ¿ ú¿ ú7¿ úN¿ úh¿ ú}¿ úí¿ úü¿ ú·¿ ù%¿ ùe¿ ùy¿ ù¡¿ ù≈¿ ù∆¿ û	¿ û¿ û/¿ ûC¿ ûx¿ ûè¿ û©¿ ûæ¿ û”¿ û‡¿ ü&¿ üj¿ ü™¿ ü√¿ †¿ †¿ †¿ †9¿ †:¿ †^¿ †|¿ †Ä¿ †Å¿ †¶¿ †ß¿ †Ê¿ †˘¿ °¿ °T¿ °f¿ °∂¿ °–¿ °‘¿ °’¿ ¢
¿ ¢¿ ¢/¿ ¢d¿ ¢é¿ ¢í¿ ¢ì¿ ¢¥¿ ¢µ¿ ¢Ô¿ £ ¿ £¿ £A¿ £W¿ £[¿ £\¿ £¿ £Ä¿ £ø¿ £–¿ £˛¿ §¿ §T¿ §b¿ §t¿ §ø¿ §◊¿ §€¿ §‹¿ •¿ •¿ •U¿ •}¿ •Å¿ •Ç¿ •Æ¿ •Ø¿ •‹¿ ¶¿ ¶d¿ ¶à¿ ¶å¿ ¶ç¿ ¶⁄¿ ß¿ ß^¿ ßu¿ ß¬¿ ßÌ¿ ßÒ¿ ßÚ¿ ®>¿ ®Ä¿ ®Õ¿ ®¯¿ ®¸¿ ®˝¿ ©>¿ ©p¿ ©ì¿ ©ó¿ ©ò¿ ©‰¿ ™¿ ™_¿ ™á¿ ™ã¿ ™å¿ ™ß¿ ™Â¿ ´¿ ´
¿ ´¿ ´A¿ ´W¿ ´[¿ ´\¿ ´É¿ ´Ñ¿ ´¡¿ ´Ê¿ ¨
¿ ¨ ¿ ¨$¿ ¨%¿ ¨Q¿ ¨R¿ ¨ì¿ ¨¥¿ ¨∏¿ ¨π¿ ¨Ê¿ ¨Á¿ ≠)¿ ≠K¿ ≠O¿ ≠P¿ ≠x¿ ≠y¿ ≠¬¿ ≠ﬂ¿ ≠„¿ ≠‰¿ Æ¿ Æ¿ Æ8¿ Æq¿ Æò¿ Æú¿ Æù¿ Æ«¿ Æ»¿ Ø¿ Ø'¿ Ø+¿ Ø,¿ Øm¿ Øé¿ Øí¿ Øì¿ Ø¿¿ Ø¡¿ ∞¿ ∞$¿ ∞(¿ ∞)¿ ∞e¿ ∞µ¿ ∞ˇ¿ ± ¿ ±&¿ ±X¿ ±ú¿ ±‹¿ ≤&¿ ≤5¿ ≤;¿ ≤w¿ ≤∆¿ ≤¯¿ ≥(¿ ≥M¿ ≥Q¿ ≥R¿ ≥ö¿ ≥„¿ ¥"¿ ¥U¿ ¥[¿ ¥p¿ ¥Å¿ ¥ª¿ ¥Á¿ ¥Î¿ ¥Ï¿ µ2¿ µn¿ µt¿ µù¿ µ»¿ µ…¿ µ¸¿ ∂F¿ ∂v¿ ∂ä¿ ∂±¿ ∂Õ¿ ∂Ë¿ ∑¿ ∑¿ ∑;¿ ∑S¿ ∑q¿ ∑é¿ ∑è¿ ∑Ÿ¿ ∑Í¿ ∑˜¿ ∏¿ ∏<¿ ∏X¿ ∏^¿ ∏~¿ ∏ò¿ ∏≥¿ ∏œ¿ ∏È¿ π¿ π¿ π<¿ πM¿ πe¿ π}¿ πù¿ π°¿ π¢¿ πæ¿ ∫¿ ∫¿ ∫C¿ ∫T¿ ∫f¿ ∫z¿ ∫ç¿ ∫§¿ ∫æ¿ ∫”¿ ∫‡¿ ª.¿ ªN¿ ªR¿ ªS¿ ª|¿ ª}¿ ª•¿ ª¶¿ ªÀ¿ ªË¿ ªÏ¿ ªÌ¿ º<¿ ºX¿ º\¿ º]¿ ºè¿ º≠¿ º±¿ º≤¿ º ¿ Ω¿ Ω)¿ Ω-¿ Ω.¿ Ωi¿ Ω¿ ΩÉ¿ ΩÑ¿ ΩÆ¿ ΩÎ¿ æ¿ æG¿ æK¿ æL¿ æú¿ æ»¿ æı¿ ø¿ ø¿ ø¿ øn¿ øò¿ ø»¿ øÍ¿ øÓ¿ øÔ¿ ¿8¿ ¿y¿ ¿¿ ¿Œ¿ ¡¿ ¡L¿ ¡É¿ ¡¨¿ ¡∞¿ ¡±¿ ¡˘¿ ¬D¿ ¬á¿ ¬ç¿ ¬›¿ √,¿ √{¿ √»¿ √ÿ¿ ƒ¿ ƒJ¿ ƒs¿ ƒw¿ ƒx¿ ƒ»¿ ≈¿ ≈,¿ ≈k¿ ≈å¿ ≈ê¿ ≈ë¿ ≈¥¿ ≈Ã¿ ≈–¿ ≈—¿ ≈˛¿ ≈ˇ¿ ∆2¿ ∆8¿ ∆M¿ ∆f¿ ∆Ö¿ ∆ã¿ ∆©¿ ∆Ù¿ «?¿ «U¿ «•¿ «¡¿ «≈¿ «∆¿ «Á¿ «Ë¿ »¿ »¿ »4¿ »E¿ »R¿ »e¿ »É¿ »§¿ »®¿ »©¿ »·¿ »‚¿ …¿ …¿ …3¿ …L¿ …å¿ …≥¿ …∑¿ …∏¿ …Ê¿ …Á¿  $¿  *¿  ?¿  V¿  j¿  Ñ¿  «¿  Â¿  È¿  Í¿ À¿ À¿ À\¿ À{¿ À¿ ÀÄ¿ ÀÆ¿ ÀÓ¿ Ã¿ Ã@¿ ÃD¿ ÃE¿ Ãq¿ Ãí¿ Ãñ¿ Ãó¿ Ãﬂ¿ ÃÙ¿ Õ¿ Õ¿ ÕH¿ ÕI¿ Õò¿ ÕÊ¿ Œ
¿ ŒG¿ ŒH¿ Œç¿ Œ“¿ Œ˜¿ Œ˝¿ œ¿ œ%¿ œ+¿ œg¿ œ¿ œ«¿ œÂ¿ œÈ¿ œÍ¿ –¿ –¿ –Q¿ –p¿ –t¿ –u¿ –∞¿ –Ã¿ —¿ —#¿ —'¿ —(¿ —W¿ —X¿ —õ¿ —∞¿ —«¿ —·¿ —ˆ¿ “¿ “D¿ “h¿ “l¿ “m¿ “∞¿ “¡¿ “Œ¿ “¿ ”0¿ ”1¿ ”n¿ ”î¿ ”ò¿ ”ô¿ ”ƒ¿ ”≈¿ ‘¿ ‘$¿ ‘(¿ ‘)¿ ‘W¿ ‘X¿ ‘É¿ ‘£¿ ‘ß¿ ‘®¿ ‘“¿ ‘Ó¿ ‘Ú¿ ‘Û¿ ’>¿ ’q¿ ’ú¿ ’π¿ ’Ω¿ ’æ¿ ’Ô¿ ÷¿ ÷¿ ÷¿ ÷h¿ ÷Ü¿ ÷å¿ ÷Õ¿ ÷˙¿ ÷˚¿ ◊%¿ ◊G¿ ◊K¿ ◊L¿ ◊ò¿ ◊¬¿ ◊√¿ ÿ¿ ÿL¿ ÿs¿ ÿí¿ ÿñ¿ ÿó¿ ÿº¿ ÿÔ¿ Ÿ'¿ ŸG¿ ŸK¿ ŸL¿ Ÿò¿ Ÿ∂¿ ŸÎ¿ ŸÏ¿ ⁄4¿ ⁄F¿ ⁄s¿ ⁄t¿ ⁄ø¿ ⁄˛¿ €%¿ €)¿ €*¿ €]¿ €^¿ €á¿ €®¿ €¨¿ €≠¿ €›¿ €˚¿ €ˇ¿ ‹ ¿ ‹J¿ ‹é¿ ‹œ¿ ‹–¿ ›¿ ›T¿ ›q¿ ›ô¿ ›º¿ ›¿¿ ›¡¿ ﬁ¿ ﬁH¿ ﬁe¿ ﬁè¿ ﬁ¥¿ ﬁ∏¿ ﬁπ¿ ﬂ¿ ﬂG¿ ﬂs¿ ﬂt¿ ﬂ¡¿ ﬂ⁄¿ ‡¿ ‡¿ ‡U¿ ‡n¿ ‡û¿ ‡ø¿ ‡√¿ ‡ƒ¿ ·¿ ·"¿ ·D¿ ·W¿ ·í¿ ·Æ¿ ·’¿ ·˜¿ ·˚¿ ·¸¿ ‚H¿ ‚]¿ ‚¿ ‚ó¿ ‚Ø¿ ‚Í¿ „¿ „1¿ „W¿ „[¿ „\¿ „¢¿ „Ì¿ ‰ ¿ ‰3¿ ‰U¿ ‰Y¿ ‰Z¿ ‰™¿ ‰«¿ ‰Ù¿ Â:¿ ÂW¿ Â[¿ Â\¿ Â©¿ Â¿¿ Â˘¿ Â˙¿ ÊE¿ Ê\¿ Êp¿ Êä¿ Ê’¿ Á¿ Á¿ Á¿ Á*¿ Á0¿ Á|¿ Áæ¿ Á⁄¿ Áﬁ¿ Áﬂ¿ Áˇ¿ ËK¿ Ën¿ Ër¿ Ës¿ Ë°¿ Ë¢¿ ËÕ¿ ËÌ¿ ËÒ¿ ËÚ¿ È*¿ ÈF¿ ÈJ¿ ÈK¿ Ès¿ Èê¿ Èî¿ Èï¿ È≤¿ ÈÓ¿ Í¿ Í¿ Í¿ Í3¿ Ír¿ Íï¿ Íô¿ Íö¿ Í≈¿ ÍÂ¿ ÍÈ¿ ÍÍ¿ Î"¿ Î#¿ Îm¿ Îò¿ Î∞¿ Î¥¿ Îµ¿ Î¯¿ Ï+¿ Ï2¿ Ï\¿ Ï{¿ Ï¿ ÏÄ¿ Ï¬¿ Ï¯¿ Ïˇ¿ Ì&¿ ÌB¿ ÌF¿ ÌG¿ Ìa¿ Ì∞¿ ÌÕ¿ Ì—¿ Ì“¿ Ó"¿ Ó[¿ Ó®¿ Ó≈¿ Ó…¿ Ó ¿ ÓË¿ Ó˜¿ Ô¿ Ô%¿ Ô;¿ ÔÑ¿ Ô”¿ Ô„¿ Ô˘¿ Ôˇ¿  ¿ $¿ %¿ t¿ ¥¿ ¸¿ Ò¿ Ò¿ Ò¿ ÒE¿ Òb¿ Òf¿ Òg¿ Ò§¿ Ò¬¿ Ò∆¿ Ò«¿ ÒÒ¿ Ú¿ Ú¿ Ú¿ Úa¿ Úô¿ Ú√¿ Ú·¿ ÚÂ¿ ÚÊ¿ Û¿ Û5¿ Û9¿ Û:¿ Ûd¿ Ûe¿ Ûå¿ Û´¿ ÛØ¿ Û∞¿ Ûÿ¿ Ûı¿ Û˘¿ Û˙¿ ÙK¿ Ùë¿ Ùï¿ Ùñ¿ Ù”¿ ı¿ ı	¿ ı
¿ ı4¿ ıL¿ ıP¿ ıQ¿ ı}¿ ıû¿ ı¢¿ ı£¿ ı»¿ ı‚¿ ıÊ¿ ıÁ¿ ˆ/¿ ˆb¿ ˆä¿ ˆé¿ ˆè¿ ˆ«¿ ˆÙ¿ ˆ¯¿ ˆ˘¿ ˜ ¿ ˜<¿ ˜@¿ ˜A¿ ˜Ö¿ ˜≈¿ ˜„¿ ˜Á¿ ˜Ë¿ ¯+¿ ¯^¿ ¯•¿ ¯ ¿ ¯Œ¿ ¯œ¿ ˘¿ ˘¿ ˘-¿ ˘F¿ ˘Y¿ ˘ß¿ ˘œ¿ ˘”¿ ˘‘¿ ˘Î¿ ˙¿ ˙'¿ ˙+¿ ˙,¿ ˙y¿ ˙†¿ ˙æ¿ ˙¬¿ ˙√¿ ˚¿ ˚T¿ ˚ó¿ ˚ò¿ ˚„¿ ¸¿ ¸8¿ ¸<¿ ¸=¿ ¸o¿ ¸∂¿ ¸’¿ ¸Ÿ¿ ¸⁄¿ ˝'¿ ˝j¿ ˝ü¿ ˝æ¿ ˝¬¿ ˝√¿ ˝ÿ¿ ˝˘¿ ˛¿ ˛¿ ˛¿ ˛a¿ ˛á¿ ˛•¿ ˛©¿ ˛™¿ ˛–¿ ˇ¿ ˇV¿ ˇá¿ ˇ∞¿ ˇ¥¿ ˇµ¿  ¿ .¿ T¿ X¿ Y¿ ®¿ Œ¿ ˇ¿%¿)¿*¿z¿§¿™¿˜¿H¿ó¿„¿&¿h¿É¿∂¿◊¿€¿‹¿,¿V¿\¿©¿˙¿I¿ï¿ÿ¿¿5¿f¿á¿ã¿å¿ÿ¿¿g¿ã¿ß¿Î¿
¿¿¿`¿£¿∏¿È¿	¿	6¿	Q¿	U¿	V¿	}¿	ô¿	ù¿	û¿	Â¿
¿

¿
¿
0¿
y¿
°¿
•¿
¶¿
˜¿
¯¿¿$¿?¿\¿|¿ñ¿Æ¿∆¿‚¿Ê¿Á¿¿¿Y¿¿É¿Ñ¿ ¿Í¿Ó¿Ô¿,¿^¿b¿c¿ï¿º¿¿¿¡¿¿^¿å¿Ø¿≥¿¥¿¿!¿%¿&¿]¿^¿í¿…¿Õ¿Œ¿Ú¿/¿V¿Z¿[¿ì¿¿¿ƒ¿≈¿Ì¿
¿¿¿Q¿é¿«¿˚¿ˇ¿ ¿I¿t¿u¿∞¿Õ¿¿<¿@¿A¿|¿ô¿›¿¿3¿7¿8¿Ü¿”¿¿i¿à¿ƒ¿≈¿¿\¿©¿ı¿.¿Q¿û¿∫¿¿¿¿S¿£¿È¿¿3¿u¿y¿z¿Ü¿¢¿È¿"¿&¿'¿v¿≈¿¿_¿ù¿–¿‘¿’¿¯¿¿¿¿c¿¨¿⁄¿ ¿H¿ô¿Œ¿¿%¿o¿≠¿˛¿¿Q¿R¿°¿È¿ 0¿ ~¿ ´¿ ¨¿ ˙¿!F¿!L¿!ô¿!„¿!¯¿"*¿"`¿"ï¿"ô¿"ö¿"È¿#¿#¿#_¿#ê¿#ø¿#‚¿#Ê¿#ËÄ‚#  Å  Å,  ÅP ÅpÅâÅå Å´ÅµÅ∏ Å›ÅÏÅÔ ÇÇÇ Ç+Ç9Ç< ÇhÇàÇã ÇØÇ«Ç  ÇÎÉÉ É#ÉNÉQ ÉkÉz  É}ÄàÉå     É¶]É´  É∆Éœ  É◊É‚  ÉÎ
É  É˜
É¸    Ñ¿‡Ö«Åπ/// A parser event listener that does nothing except throw exceptions
/// on parser errors.
///
/// Events are methods that begin with one of: `begin`, `end`, or `handle`.
///
/// Events starting with `begin` and `end` come in pairs. Normally, a
/// `beginFoo` event is followed by an `endFoo` event. There's a few exceptions
/// documented below.
///
/// Events starting with `handle` are used when isn't possible to have a begin
/// event.   ÖıÖ˛    ÅpÜÜ  ÜÜ$   Ü/#Ü4  ÜCÜJ   ÜV_Ü[  Üh	Üm  ÜsÜz  ÜÖÜå   ÜπÄá8u/// Called after the parser has consumed a sequence of patternFields that
/// forms the arguments to an objectPattern áR	áW  á]ád  áoáv   á≠ÄöáÍ5/// Handle async modifiers `async`, `async*`, `sync`. á˛à  àà   àKtàõH/// Ended by either [endAwaitExpression] or [endInvalidAwaitExpression]. à∞à∑   à√Äπâ!T/// One of the two possible corresponding end events for
/// [beginAwaitExpression]. â4â;  âFâM   âÄÄÂâﬁT/// One of the two possible corresponding end events for
/// [beginAwaitExpression]. âˇä  ää  ä!ä.   äi4än  äyäÄ  äÜäë   ä°sä¶  ä∂	äª  ä¡ä»  ä”ä⁄  ä„äÓ   ãÄ≈ã≥Äè/// Called to handle a block that has been parsed but is not associated
/// with any top level function declaration. Substructures:
/// - block ãŒã’   ã·!ãÊ  ãÛã˙   å0å    å:.å?  åSåZ   åliåq  åÉåä  åñåû  å£å™   åŸÄÚçÖÄ†/// Handle the start of the body of a class, mixin or extension declaration
/// beginning at [token]. The actual kind of declaration is indicated by
/// [kind]. ç¶ç∑  çºç√   çœÅ~é¨Äœ/// Handle the end of the body of a class, mixin or extension declaration.
/// The only substructures are the class, mixin or extension members.
///
/// The actual kind of declaration is indicated by [kind]. é“é„  éËéÌ  é˘è   èè   èQÅáêôÅ2/// Called before parsing a class declaration, mixin declaration, or named
/// mixin application.
///
/// At this point only the `class` or `mixin` keyword have been seen,
/// so we know a declaration is coming but not its name or type
/// parameter declarations.
///
/// Ended by [endTopLevelDeclaration]. ê…ê–   ê‹Ç'ëÙÅ/// Handle the beginning of a class declaration.
/// [begin] may be the same as [name], or may point to modifiers
/// (or extraneous modifiers in the case of recovery) preceding [name].
///
/// At this point we have parsed the name and type parameter declarations. 
íí  í$í,  í@íH  íYía  ísí{  íãíì  í®í∞  í¡í…  í‹í‰  íı
í¸   ìÅÇî-Å/// Handle an extends clause in a class declaration. Substructures:
/// - supertype (may be a mixin application)
/// The typeCount is for error recovery: Invalid code might have more than one
/// class specified in the extends clause. A parser error has already been
/// issued. î@îH  îWî\   îçÄﬁï
q/// Handle an implements clause in a class, mixin or enum declaration.
/// Substructures:
/// - implemented types ïï#  ï5ï:   ïoÅQñWÄ–/// Handle the header of a class declaration.  Substructures:
/// - metadata
/// - modifiers
/// - class name
/// - type variables
/// - supertype
/// - with clause
/// - implemented types
/// - native clause ñiñp  ñvñ}  ñäñí   ñƒÅ”ò-ÅS/// Handle recovery associated with a class or extension type header.
/// This may be called multiple times after [handleClassHeader]
/// to recover information about the previous class header.
/// The substructures are a subset of
/// and in the same order as [handleClassHeader]:
/// - supertype
/// - with clause
/// - implemented types òLòc   òõÄ«ô^/// Handle the end of a class declaration.  Substructures:
/// - class header
/// - class body ôô   ô+ô2   ôfÄØôû0/// Handle the beginning of a mixin declaration. ô¥ôª  ô∆ôŒ  ô·ôÈ  ôÛô˙  ö
ö   öÄ≠öyV/// Handle an on clause in a mixin declaration. Substructures:
/// - implemented types öáöè  öôöû   ö ÄÛõuÄô/// Handle the header of a mixin declaration.  Substructures:
/// - metadata
/// - mixin name
/// - type variables
/// - on types
/// - implemented types õáõé   õ¡Å’ùRÅy/// Handle recovery associated with a mixin header.
/// This may be called multiple times after [handleMixinHeader]
/// to recover information about the previous mixin header.
/// For otherwise legal input the substructures are a subset of
/// and in the same order as [handleMixinHeader]
/// - on types
/// - implemented types
/// but also covers the illegal
/// - with clause   ùöÄ–ûg/// Handle the end of a mixin declaration.  Substructures:
/// - mixin header
/// - class or mixin body û!û(  û3û:   ûnÄßû‡f/// Begins a not-further-categorized top-level declaration.
///
/// Ended by [endTopLevelDeclaration]. üü   üÅq†OÅ"/// Handle the beginning of an extension methods declaration.  Substructures:
/// - metadata
///
/// At this point only the `extension` keyword have been seen, so we know a
/// declaration is coming but not its name or type parameter declarations.
///
/// Ended by [endTopLevelDeclaration]. †p†w   †éÅ°MÄ±/// Handle the beginning of an extension methods declaration.  Substructures:
/// - type variables
///
/// At this point we have parsed the name and type parameter declarations. °n°v  °É°ä  °õ°£   °ÆÅ8¢QÄï/// Handle the end of an extension methods declaration.  Substructures:
/// - substructures from [beginExtensionDeclaration]
/// - on type
/// - body ¢i¢p  ¢{¢Ç  ¢ô¢°  ¢´¢≤   ¢ÍÅ£¶ÄÆ/// Handle the beginning of an extension type declaration.  Substructures:
/// - type variables
///
/// At this point we have parsed the name and type parameter declarations. £À£”  £‚£È  £˙
§   §Åà§·Ä≈/// Handle the end of an extension methods declaration.  Substructures:
/// - substructures from [beginExtensionTypeDeclaration]
/// - primary constructor formals
/// - implements clause
/// - body §˝•  ••  •*•1  •B•I  •U•\   •òÄ‘¶w/// Handle the start of a primary constructor declaration, currently only
/// occurring in extension type declarations. ¶1¶8   ¶pÅﬂß…ÅA/// Handle the end of a primary constructor declaration, currently only
/// occurring in extension type declarations. [constKeyword] is the 'const'
/// keyword, if present, in
///
///   extension type const ExtensionType() {}
///
/// Substructures:
/// - constructor name (if [hasConstructorName] is `true`)
/// - formals ßÊßÌ  ß¯®   ®®   ®SÄ√®◊z/// Handle the omission of a primary constructor declaration. Currently only
/// occurring in extension type declarations. ®Ú®˘  ®ˇ©   ©%©  ©0©7   ©CA©H  ©W	©\   ©à)©ç  ©¢©©   ©µÅ<™ÿÅ/// This method exists for analyzer compatibility only
/// and will be removed once analyzer/fasta integration is complete.
///
/// This is called when [parseDirectives] has parsed all directives
/// and is skipping the remainder of the file.  Substructures:
/// - metadata   ™ıV™˙  ´	´  ´´   ´O&´T  ´f´m   ´yH´~  ´é´ï   ´≈.´   ´‰´Î   ´˜ÄΩ´¸  ¨¨  ¨!¨)  ¨@¨G  ¨P7¨m   ¨∏*¨Ω  ¨”¨⁄   ¨Ê|¨Î  ≠≠  ≠≠  ≠+≠2   ≠f.≠k  ≠Ö≠å   ≠òU≠ù  ≠µ≠º   ≠Ò,≠ˆ  ÆÆ   Æ!TÆ&  Æ<ÆC   Æy$Æ~  ÆàÆè   Æ°ÄıØi/// Handle the end of an enum declaration.  Substructures:
/// - [memberCount] times:
///   - Enum member ØØ%  Ø0Ø7  ØCØJ  ØZØ_  ØkØr   ØöÇ)∞™Ä¯/// Handle the end of an enum constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ∞Ω∞≈  ∞Œ∞’  ∞‡∞Á  ∞¯±   ±±   ±«ÄÀ≤1^/// Handle the enum elements. Substructures:
/// - [elementsCount] times:
///   - Enum element ≤D≤K  ≤\≤a   ≤ñÅ,≥PÄ®/// Handle the header of an enum declaration.  Substructures:
/// - Metadata
/// - Enum name (identifier)
/// - type variables
/// - with clause
/// - implemented types ≥h≥p  ≥}≥Ñ  ≥ê≥ó   ≥∆Äø¥*X/// Handle the enum element. Substructures:
/// - Metadata
/// - Enum value (identifier) ¥<¥C  ¥N¥V   ¥âÄü¥é  ¥™¥±  ¥º¥√  ¥“¥Ÿ   µ, µ1  µ=µD   µPÄŸµ‹|/// Handle the end of an export directive.  Substructures:
/// - metadata
/// - uri
/// - conditional uris
/// - combinators µÊµÌ  µ˚∂   ∂-Å%∂ÓÄµ/// Called by [Parser] after parsing an extraneous expression as error
/// recovery. For a stack-based listener, the suggested action is to discard
/// an expression from the stack. ∑	∑  ∑∑   ∑VV∑[  ∑u∑|   ∑∞Äˆ∏-s/// Note that this is ended by [endClassFactoryMethod],
/// [endMixinFactoryMethod] or [endExtensionFactoryMethod]. ∏@∏Q  ∏a∏h  ∏{∏É  ∏ë∏ô   ∏™ÄÉ∏Ø  ∏Ã∏”  ∏ﬁ∏Â  ∏Ù∏˚   π1Ä‡π6  πSπZ  πeπl  π{πÇ   ∫Ä‰∫  ∫;∫B  ∫M∫T  ∫c∫j   ∫˝ÄËª  ª'ª.  ª9ª@  ªOªV   ªÈÄÖªÓ  ºº
  ºº  º!º)  º=ºE  ºTº\   ºrÅ)ºw  ºëºô  º´º≥  º∆ºŒ  ºÎºÚ  ΩΩ
  Ω!Ω)  Ω>ΩS  Ω^Ωj   ΩüeΩ§  ΩΩΩƒ  Ω Ω÷   æ;æ  æ#æ*  æ0æ<   æGÄÖæL  æg	æl  æræy  æÑæã  æîæ†   æ–ÅˆøöÄ∂/// Handle the end of a class field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
ø∞ø∏  øÃø‘  øÁøÔ  ¿ @¿ @  ¿ @¿ @%  ¿ @:¿ @B  ¿ @R¿ @Z  ¿ @p	¿ @u  ¿ @Å¿ @à  ¿ @ô¿ @†   ¿ @ É¿ AîÄ∂/// Handle the end of a mixin field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
¿ A™¿ A≤  ¿ A∆¿ AŒ  ¿ A·¿ AÈ  ¿ A˝¿ B  ¿ B¿ B  ¿ B4¿ B<  ¿ BL¿ BT  ¿ Bj	¿ Bo  ¿ B{¿ BÇ  ¿ Bì¿ Bö   ¿ C”É¿ D°Ä∫/// Handle the end of a extension field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
¿ Dª¿ D√  ¿ D◊¿ Dﬂ  ¿ DÚ¿ D˙  ¿ E¿ E  ¿ E(¿ E0  ¿ EE¿ EM  ¿ E]¿ Ee  ¿ E{	¿ EÄ  ¿ Eå¿ Eì  ¿ E§¿ E´   ¿ F‰É¿ G∑Äø/// Handle the end of a extension type field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
¿ G’¿ G›  ¿ GÒ¿ G˘  ¿ H¿ H  ¿ H(¿ H0  ¿ HB¿ HJ  ¿ H_¿ Hg  ¿ Hw¿ H  ¿ Hï	¿ Hö  ¿ H¶¿ H≠  ¿ Hæ¿ H≈   ¿ I˛Çƒ¿ J»Ä∂/// Handle the end of an enum field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
¿ J›¿ JÂ  ¿ J˘¿ K  ¿ K¿ K  ¿ K0¿ K8  ¿ KJ¿ KR  ¿ Kg¿ Ko  ¿ K¿ Ká  ¿ Kù	¿ K¢  ¿ KÆ¿ Kµ  ¿ K∆¿ KÕ   ¿ L∆Åﬂ¿ M—ÄÛ/// Handle the end of an enum method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ Mﬂ¿ MÁ  ¿ M¿ M˜  ¿ N¿ N	  ¿ N¿ N"  ¿ N4¿ N;   ¿ N©ÄŸ¿ Ol/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was an empty statement. ¿ OB¿ OI   ¿ OÜÄÙ¿ Pq/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was an expression statement. ¿ P)¿ P0  ¿ P6
¿ P<   ¿ P~ÅC¿ Q>Ä¥/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was a `localVariableDeclaration` of the form
/// `metadata initializedVariableDeclaration ';'`. ¿ Qk¿ Qr  ¿ Qx
¿ Q~   ¿ Q≈ÅR¿ RÅÄ∞/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was a `localVariableDeclaration` of the form
/// `metadata patternVariableDeclaration ';'`. ¿ R∂¿ RΩ  ¿ R≈¿ RÃ   ¿ SÄè¿ Sâd/// Marks the start of a for statement which is ended by either
/// [endForStatement] or [endForIn]. ¿ Sõ¿ S¢   ¿ SÆÅF¿ TÜÄÃ/// Marks the end of parsing the control structure of a for statement
/// or for control flow entry up to and including the closing parenthesis.
/// `for` `(` initialization `;` condition `;` updaters `)` ¿ Tô¿ T†  ¿ T´¿ T≤  ¿ T¬¿ T…  ¿ T◊¿ T‹   ¿ T¯H¿ T˝  ¿ U¿ U   ¿ UD*¿ UI  ¿ U_¿ Uf   ¿ UrP¿ Uw  ¿ Uã¿ Uí   ¿ U∆Ç7¿ W~Å§/// Marks the end of parsing the control structure of a for-in statement
/// or for control flow entry up to and including the closing parenthesis.
/// If [patternKeyword] is `null`, this takes the form:
///   `for` `(` (type)? identifier `in` iterator `)`
/// If [patternKeyword] is not `null`, it is either a `var` or `final` token,
/// and this takes the form:
///   `for` `(` patternKeyword pattern `in` iterator `)` ¿ Wì¿ Wõ  ¿ W¶¿ W≠  ¿ Wº¿ W√  ¿ W”¿ W€  ¿ WÍ¿ WÒ   ¿ XP:¿ XU  ¿ X^¿ Xe   ¿ Xé)¿ Xì  ¿ X®¿ XØ   ¿ XªK¿ X¿  ¿ X”¿ X⁄   ¿ Y
#¿ Y  ¿ Y¿ Y%   ¿ Y1B¿ Y6  ¿ YC¿ YJ   ¿ YwÅì¿ ZﬁÅS/// Handle the beginning of a named function expression which isn't legal
/// syntax in Dart.  Useful for recovering from JavaScript code being pasted
/// into a Dart program, as it will interpret `function foo() {}` as a named
/// function expression with return type `function` and name `foo`.
///
/// Substructures:
/// - Type variables ¿ Z˚¿ [   ¿ [ÇI¿ \˛ÅŒ/// A named function expression which isn't legal syntax in Dart.
/// Useful for recovering from JavaScript code being pasted into a Dart
/// program, as it will interpret `function foo() {}` as a named function
/// expression with return type `function` and name `foo`.
///
/// Substructures:
/// - Type variables
/// - Modifiers
/// - Return type
/// - Name
/// - Formals
/// - Initializers
/// - Async modifier
/// - Function body (block or arrow expression). ¿ ]¿ ]    ¿ ][Ä¶¿ ]‘m/// Handle the beginning of a local function declaration.  Substructures:
/// - Metadata
/// - Type variables ¿ ]Ú¿ ]˘   ¿ ^Åc¿ _ÄÔ/// A function declaration.
///
/// Substructures:
/// - Metadata
/// - Type variables
/// - Return type
/// - Name
/// - Type variables
/// - Formals
/// - Initializers
/// - Async modifier
/// - Function body (block or arrow expression). ¿ _.¿ _5   ¿ _lÅ;¿ `ÅÅ/// This method is invoked when the parser sees that a function has a
/// block function body.  This method is not invoked for empty or expression
/// function bodies, see the corresponding methods [handleEmptyFunctionBody]
/// and [handleExpressionFunctionBody]. ¿ `ò¿ `ü   ¿ `´Ç¿ b^Å°/// This method is invoked by the parser after it finished parsing a block
/// function body.  This method is not invoked for empty or expression
/// function bodies, see the corresponding methods [handleEmptyFunctionBody]
/// and [handleExpressionFunctionBody].  The [beginToken] is the '{' token,
/// and the [endToken] is the '}' token of the block.  The number of
/// statements is given as the [count] parameter. ¿ bs	¿ bx  ¿ b~¿ bÖ  ¿ bê¿ bó   ¿ bÃL¿ b—  ¿ bÊ¿ bÌ   ¿ cÅ¿ c·Ä∑/// Handle the end of a function body that was skipped by the parser.
///
/// The boolean [isExpressionBody] indicates whether the function body that
/// was skipped used "=>" syntax. ¿ c˚¿ d  ¿ d¿ d   ¿ d%&¿ d*  ¿ d<¿ dC   ¿ dOW¿ dT  ¿ dd¿ dk  ¿ dv¿ d}   ¿ d™!¿ dØ  ¿ dº¿ d√   ¿ dœÇ6¿ fÇÅë/// Handle the end of a typedef declaration.
///
/// If [equals] is null, then we have the following substructures:
/// - Metadata
/// - Return type
/// - Name (identifier)
/// - Alias type variables
/// - Formal parameters
///
/// If [equals] is not null, then the have the following substructures:
/// - Metadata
/// - Name (identifier)
/// - Alias type variables
/// - Type (FunctionTypeAnnotation) ¿ fç¿ fï  ¿ f¢¿ f©  ¿ f∏¿ f¿  ¿ fÕ¿ f‘   ¿ g	Ä»¿ gÇm/// Handle the end of a class with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList) ¿ gò¿ gü   ¿ g’x¿ h./// Handle the absence of a class with clause.   ¿ hQÅI¿ iMÄÍ/// Handle the end of an enum with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList)
///
/// This method is separated from [handleClassWithClause] to simplify
/// handling the different objects in the context. ¿ ib¿ ii   ¿ iûv¿ i‘./// Handle the absence of an enum with clause.   ¿ jÅD¿ kÄ„/// Handle the end of a mixin with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList)
///
/// This method is separated from [handleClassWithClause] and
/// [handleEnumWithClause] as it is an error state. ¿ k#¿ k*   ¿ k`Ç<¿ lÉÅ/// Handle the beginning of a named mixin application.
/// [beginToken] may be the same as [name], or may point to modifiers
/// (or extraneous modifiers in the case of recovery) preceding [name].
///
/// At this point we have parsed the name and type parameter declarations. 
¿ l•¿ l¨  ¿ lΩ¿ l≈  ¿ lŸ¿ l·  ¿ lÚ¿ l˙  ¿ m¿ m  ¿ m$¿ m,  ¿ mA¿ mI  ¿ mZ¿ mb  ¿ mu¿ m}  ¿ mé
¿ mï   ¿ m†Å¿ n4ÄÜ/// Handle a named mixin application with clause (e.g. "A with B, C").
/// Substructures:
/// - supertype
/// - mixin types (TypeList) ¿ nZ¿ na   ¿ nßÇ¯¿ p˚Ç0/// Handle the end of a named mixin declaration.  Substructures:
/// - metadata
/// - modifiers
/// - class name
/// - type variables
/// - supertype
/// - with clause
/// - implemented types (TypeList)
///
/// TODO(paulberry,ahe): it seems inconsistent that for a named mixin
/// application, the implemented types are a TypeList, whereas for a class
/// declaration, each implemented type is listed separately on the stack, and
/// the number of implemented types is passed as a parameter.
///
/// TODO(jensj): Rename `begin` to `beginToken` for consistency. ¿ q¿ q  ¿ q!¿ q(  ¿ q5¿ q<  ¿ qI¿ qQ  ¿ qc¿ qj   ¿ q£$¿ q®  ¿ q≤¿ qπ   ¿ qÀÄû¿ r3^/// Handle the end of a "hide" combinator.  Substructures:
/// - hidden names (IdentifierList) ¿ r;¿ rB   ¿ rmJ¿ rr  ¿ rá	¿ rå   ¿ rª"¿ r¿  ¿ rŒ¿ r’   ¿ r·;¿ rÊ  ¿ rÚ	¿ r˜   ¿ s %¿ s%  ¿ s6¿ s=   ¿ sIW¿ sN  ¿ s]¿ sd  ¿ sl¿ st   ¿ s§'¿ s©  ¿ sº¿ s√   ¿ sœG¿ s‘  ¿ sÂ¿ sÏ   ¿ t'¿ t  ¿ t2¿ t9   ¿ tEG¿ tJ  ¿ t[¿ tb   ¿ tê(¿ tï  ¿ t°¿ t®   ¿ tºÅR¿ uÆÄ‰/// Signals that the current import is deferred and/or has a prefix
/// depending upon whether [deferredKeyword] and [asKeyword]
/// are not `null` respectively. Substructures:
/// - prefix identifier (only if asKeyword != null) ¿ u¡¿ u…  ¿ uŸ¿ u·   ¿ vÅ	¿ v∏Äî/// Handle the end of an import directive.  Substructures:
/// - metadata
/// - uri
/// - conditional uris
/// - prefix identifier
/// - combinators ¿ v¬¿ v…  ¿ v◊¿ vﬂ  ¿ vÏ¿ vÙ   ¿ wÅú¿ xpÅ=/// Handle recovery associated with an import directive.
/// This may be called multiple times after [endImport]
/// to recover information about the previous import directive.
/// The substructures are a subset of and in the same order as [endImport]:
/// - conditional uris
/// - prefix identifier
/// - combinators ¿ xÑ¿ xå   ¿ xø)¿ xƒ  ¿ xŸ¿ x‡   ¿ xÏI¿ xÒ  ¿ y	¿ y	   ¿ y9,¿ y>  ¿ yR¿ yY   ¿ yiÅ&¿ z$Ä≠/// Handle the end of a conditional URI construct.  Substructures:
/// - Dotted name
/// - Condition (literal string; only if [equalSign] != null)
/// - URI (literal string) ¿ z6¿ z=  ¿ zG¿ zN  ¿ zX¿ z`   ¿ zìY¿ zò  ¿ z©	¿ zÆ  ¿ z¥¿ zª   ¿ z4¿ zı  ¿ {¿ {   ¿ {(y¿ {-  ¿ {K¿ {R  ¿ {X¿ {_   ¿ {•/¿ {™  ¿ {≈¿ {Ã   ¿ {ÿ[¿ {›  ¿ {ˆ¿ {˝   ¿ |7*¿ |<  ¿ |R¿ |Y   ¿ |eÄæ¿ |∆W/// Handle the end of a field initializer.  Substructures:
/// - Initializer expression ¿ |⁄¿ |·  ¿ |Ï¿ |Û   ¿ }'ÄÇ¿ }Z+/// Handle the lack of a field initializer. ¿ }s¿ }z   ¿ }≠-¿ }≤  ¿ }À¿ }“   ¿ }ﬁÄø¿ ~BZ/// Handle the end of a variable initializer. Substructures:
/// - Initializer expression. ¿ ~Y¿ ~`   ¿ ~°Äâ¿ ~’,/// Used when a variable has no initializer. ¿ ~Ò¿ ~¯   ¿ .%¿ 3  ¿ D¿ K   ¿ WQ¿ \  ¿ k¿ r   ¿ ¨&¿ ±  ¿ √¿     ¿ ÷e¿ €  ¿ Î	¿   ¿ ˆ¿ ˝  ¿ Ä¿ Ä   ¿ Ä?A¿ ÄD    ¿ ÄÑÅ¿ ÅIÄπ/// Called after the listener has recovered from an invalid expression. The
/// parser will resume parsing from [token]. Exactly where the parser will
/// resume parsing is unspecified. ¿ Åa¿ Åh   ¿ ÅöÅ'¿ ÇpÄ /// Called after the listener has recovered from an invalid function
/// body. The parser expected an open curly brace `{` and will resume parsing
/// from [token] as if a function body had preceded it. ¿ Çä¿ Çë   ¿ Ç≈Å ¿ ÉrÄ°/// Called after the listener has recovered from an invalid type. The parser
/// expected an identifier, and will resume parsing type arguments from
/// [token]. ¿ Éç¿ Éî   ¿ É…:¿ ÉŒ  ¿ É⁄¿ É·   ¿ Ñ:¿ Ñ  ¿ Ñ"¿ Ñ)  ¿ Ñ/¿ Ñ4   ¿ ÑEP¿ ÑJ  ¿ Ñ^¿ Ñc   ¿ ÑôL¿ Ñû  ¿ Ñ∑¿ Ñæ  ¿ ÑÕ¿ Ñ‘   ¿ ÑÈÄÒ¿ ÖU`/// Handle the end of a library augmentation directive.  Substructures:
/// - metadata
/// - uri ¿ Ös¿ Öz  ¿ Öâ¿ Öê  ¿ Öü¿ Ö¶   ¿ Öﬁ%¿ Ö„  ¿ ÖÙ¿ Ö˚   ¿ ÜÄÁ¿ Üàu/// Handle the end of a library directive.  Substructures:
/// - Metadata
/// - Library name (a qualified identifier) ¿ Üó¿ Üû  ¿ Ü≠¿ Ü¥  ¿ Üæ¿ Üƒ   ¿ ÜÚ^¿ Ü˜  ¿ á¿ á  ¿ á¿ á!   ¿ áTÄ◊¿ á“t/// Called after the parser has consumed a mapPatternEntry, consisting of an
/// expression, a colon, and a pattern. ¿ áË¿ áÔ  ¿ áı¿ á¸   ¿ à/'¿ à4  ¿ àG¿ àN   ¿ àZM¿ à_  ¿ à}¿ àÑ  ¿ àê¿ àò   ¿ à´b¿ à∞  ¿ à¡¿ à∆  ¿ àŸ¿ à‡   ¿ âm¿ â  ¿ â0¿ â7  ¿ âB¿ âG   ¿ âÇÅ¿ äÅÄÒ/// Called for class-like members (class, mixin, extension), but each member
/// should also have a more specific begin/end pair, e.g.
/// [beginFactoryMethod]/[endClassFactoryMethod]/[endMixinFactoryMethod]/
/// [endExtensionFactoryMethod].   ¿ äïÄô¿ äÊG/// Handle an invalid member declaration. Substructures:
/// - metadata ¿ ä˙¿ ã   ¿ ã2ÅŒ¿ å◊Åè/// This event is added for convenience to the listener.
/// Members will actually be begin/end'ed by more specific
/// events as well.
/// Normally listeners should probably override
/// [endClassFields], [endMixinFields], [endExtensionFields],
/// [endClassMethod], [endMixinMethod], [endExtensionMethod],
/// [endClassConstructor], [endMixinConstructor],
/// or [endExtensionConstructor] instead.   ¿ çÇ¿ éÅ	/// Handle the beginning of a class-like method declaration.  Substructures:
/// - metadata
/// Note that this is ended with [endClassConstructor], [endClassMethod],
/// [endExtensionConstructor], [endExtensionMethod], [endMixinConstructor] or
/// [endMixinMethod]. ¿ é0¿ éA  ¿ éW¿ é_  ¿ ér¿ éz  ¿ éé¿ éñ  ¿ é®¿ é∞  ¿ é≈¿ éÕ  ¿ é„¿ éÎ  ¿ é˙
¿ è   ¿ èÅ°¿ êÄÛ/// Handle the end of a class method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ ê&¿ ê.  ¿ ê7¿ ê>  ¿ êI¿ êP  ¿ êa¿ êi  ¿ ê{¿ êÇ   ¿ ê±Ç ¿ ëºÄÛ/// Handle the end of a mixin method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ ëÀ¿ ë”  ¿ ë‹¿ ë„  ¿ ëÓ¿ ëı  ¿ í¿ í  ¿ í ¿ í'   ¿ í’Ç(¿ ì‰Ä˜/// Handle the end of a extension method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ ì˜¿ ìˇ  ¿ î¿ î  ¿ î¿ î!  ¿ î2¿ î:  ¿ îL¿ îS   ¿ ïÇ1¿ ñÄ¸/// Handle the end of a extension type method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ ñ,¿ ñ4  ¿ ñ=¿ ñD  ¿ ñU¿ ñ\  ¿ ñg¿ ño  ¿ ñÅ¿ ñà   ¿ ó6Ç*¿ òFÄ¯/// Handle the end of a class constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ òZ¿ òb  ¿ òk¿ òr  ¿ ò}¿ òÑ  ¿ òï¿ òù  ¿ òØ¿ ò∂   ¿ ôdÇ*¿ ötÄ¯/// Handle the end of a mixin constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ öà¿ öê  ¿ öô¿ ö†  ¿ ö´¿ ö≤  ¿ ö√¿ öÀ  ¿ ö›¿ ö‰   ¿ õíÇ2¿ ú¶Ä¸/// Handle the end of a extension constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ úæ¿ ú∆  ¿ úœ¿ ú÷  ¿ úÁ¿ úÓ  ¿ ú˘¿ ù  ¿ ù¿ ù   ¿ ù»ÇF¿ ûÁÅ/// Handle the end of an extension type constructor declaration.
/// Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ¿ ü¿ ü  ¿ ü¿ ü  ¿ ü,¿ ü3  ¿ ü>¿ üF  ¿ üX¿ ü_   ¿ †&¿ †  ¿ †)¿ †0   ¿ †<C¿ †A  ¿ †Q	¿ †V   ¿ †É"¿ †à  ¿ †ñ¿ †ù   ¿ †©Å*¿ °mÄ¥/// Handle the end of a metadata annotation.  Substructures:
/// - Identifier
/// - Type arguments
/// - Constructor name (only if [periodBeforeName] is not `null`)
/// - Arguments ¿ °y¿ °Ä  ¿ °ã¿ °ì  ¿ °§¿ °´   ¿ °◊2¿ °‹  ¿ °˙¿ ¢   ¿ ¢ÄÑ¿ ¢  ¿ ¢5	¿ ¢:  ¿ ¢@¿ ¢G  ¿ ¢R¿ ¢Y   ¿ ¢ï¿ ¢ö  ¿ ¢§¿ ¢´   ¿ ¢∑Ä£¿ £P/// Handle the end of a part directive.  Substructures:
/// - metadata
/// - uri ¿ £¿ £"  ¿ £.¿ £5   ¿ £^ ¿ £c  ¿ £o¿ £v   ¿ £ÇÅX¿ §iÄ’/// Handle the end of a "part of" directive.  Substructures:
/// - Metadata
/// - Library name (a qualified identifier)
///
/// If [hasName] is true, this part refers to its library by name, otherwise,
/// by URI. ¿ §z¿ §Å  ¿ §ç¿ §î  ¿ §û¿ §•  ¿ §Ø¿ §µ   ¿ §ﬁ0¿ §„  ¿ §ˇ¿ •   ¿ •n¿ •  ¿ •1¿ •8  ¿ •C¿ •J   ¿ •Ñ)¿ •â  ¿ •û¿ ••   ¿ •±Ä⁄¿ ¶%j/// Handle the end of a `native` function.
/// The [handleNativeClause] event is sent prior to this event. ¿ ¶>¿ ¶E  ¿ ¶Q¿ ¶X   ¿ ¶èÅa¿ ß|Äﬂ/// Called after the [handleNativeClause] event when the parser determines
/// that the native clause should be discarded / ignored.
/// For example, this method is called a native clause is followed by
/// a function body. ¿ ßú¿ ß£  ¿ ßØ¿ ß∂   ¿ ßÙÅ¿ ®áÄâ/// Handle the end of a `native` function that was skipped by the parser.
/// The [handleNativeClause] event is sent prior to this event. ¿ ®ß¿ ®Æ  ¿ ®∫¿ ®¡   ¿ ®ˇÄó¿ ©E>/// This method is invoked when a function has the empty body. ¿ ©]¿ ©d   ¿ ©öÄ¿ ™y/// This method is invoked when parser finishes parsing the corresponding
/// expression of the expression function body. ¿ ™:¿ ™A  ¿ ™L¿ ™T   ¿ ™é{¿ ™ì  ¿ ™≠¿ ™≥  ¿ ™¡¿ ™»  ¿ ™”¿ ™⁄   ¿ ´M¿ ´  ¿ ´¿ ´$  ¿ ´/¿ ´6   ¿ ´^$¿ ´c  ¿ ´m¿ ´t   ¿ ´ÜÄù¿ ´Ì]/// Handle the end of a "show" combinator.  Substructures:
/// - shown names (IdentifierList) ¿ ´ı¿ ´¸   ¿ ¨')¿ ¨,  ¿ ¨A¿ ¨H   ¿ ¨Tc¿ ¨Y  ¿ ¨l¿ ¨s  ¿ ¨Å¿ ¨à   ¿ ¨ª*¿ ¨¿  ¿ ¨÷¿ ¨›   ¿ ¨Èe¿ ¨Ó  ¿ ≠¿ ≠	  ¿ ≠¿ ≠   ¿ ≠R%¿ ≠W  ¿ ≠h¿ ≠o   ¿ ≠{g¿ ≠Ä  ¿ ≠è¿ ≠î  ¿ ≠û¿ ≠•  ¿ ≠∞¿ ≠∑   ¿ ≠Ê/¿ ≠Î  ¿ Æ¿ Æ   ¿ ÆÄÇ¿ Æ  ¿ Æ>¿ ÆC  ¿ ÆM¿ ÆT  ¿ Æ_¿ Æf   ¿ Æü'¿ Æ§  ¿ Æ∑¿ Ææ   ¿ Æ `¿ Æœ  ¿ Æ‡¿ ÆÁ  ¿ ÆÒ¿ Æˆ   ¿ Ø.c¿ Ø3  ¿ ØI¿ ØP  ¿ Ø[¿ Øb   ¿ Øï*¿ Øö  ¿ Ø∞¿ Ø∑   ¿ Ø√d¿ Ø»  ¿ Ø‹¿ Ø„  ¿ Ø¿ Ø˜   ¿ ∞+É%¿ ≤ˇÇ≤/// This event is added for convenience for the listener.
/// All top-level declarations will actually be begin/end'ed by more specific
/// events as well, e.g. [beginClassDeclaration]/[endClassDeclaration],
/// [beginEnum]/[endEnum] etc.
///
/// Normally listeners should probably override
/// [endClassDeclaration], [endNamedMixinApplication], [endEnum],
/// [endTypedef], [endLibraryName], [endImport], [endExport],
/// [endPart], [endPartOf], [endTopLevelFields], or [endTopLevelMethod]
/// instead.
///
/// Started by one of [beginExtensionDeclarationPrelude],
/// [beginClassOrMixinOrNamedMixinApplicationPrelude], [beginTopLevelMember]
/// or [beginUncategorizedTopLevelDeclaration]. ¿ ≥¿ ≥   ¿ ≥TÅñ¿ ¥àÅ /// Called by the [Parser] when it recovers from an invalid top level
/// declaration, where [endToken] is the last token in the declaration
/// This is called after the begin/end metadata star events,
/// and is followed by [endTopLevelDeclaration].
///
/// Substructures:
/// - metadata ¿ ¥©¿ ¥∞   ¿ ¥ÓÄŸ¿ µ§Ä®/// Marks the beginning of a top level field or method declaration.
/// See also [endTopLevelFields] and [endTopLevelMethod].
///
/// Ended by [endTopLevelDeclaration]. ¿ µ∏¿ µø   ¿ µÀÅ¬¿ ∂}Ä¶/// Marks the beginning of a fields declaration.
/// Note that this is ended with [endTopLevelFields], [endClassFields],
/// [endMixinFields] or [endExtensionFields]. 	¿ ∂ê¿ ∂°  ¿ ∂∑¿ ∂ø  ¿ ∂”¿ ∂€  ¿ ∂Ó¿ ∂ˆ  ¿ ∑
¿ ∑  ¿ ∑$¿ ∑,  ¿ ∑A¿ ∑I  ¿ ∑Y¿ ∑a  ¿ ∑w¿ ∑~   ¿ ∑ëÇ¿ ∏ÖÄﬁ/// Handle the end of a top level variable declaration.  Substructures:
/// - Metadata
/// - Type
/// - Repeated [count] times:
///   - Variable name (identifier)
///   - Field initializer
///
/// Started by [beginFields]. 	¿ ∏û¿ ∏¶  ¿ ∏π¿ ∏¡  ¿ ∏’¿ ∏›  ¿ ∏Ô¿ ∏˜  ¿ π¿ π  ¿ π$¿ π,  ¿ πB	¿ πG  ¿ πS¿ πZ  ¿ πk¿ πr   ¿ π§a¿ π©  ¿ πƒ¿ πÀ  ¿ πÿ¿ π‡  ¿ πÌ¿ πı   ¿ ∫	ÅH¿ ∫ÁÄ∆/// Handle the end of a top level method.  Substructures:
/// - metadata
/// - modifiers
/// - return type
/// - identifier
/// - type variables
/// - formal parameters
/// - async marker
/// - body ¿ ∫˘¿ ª   ¿ ª¿ ª  ¿ ª¿ ª#   ¿ ªU&¿ ªZ  ¿ ªl¿ ªs   ¿ ª%¿ ªÑ  ¿ ªï¿ ªú   ¿ ª®C¿ ª≠  ¿ ªº¿ ª√   ¿ ªÔl¿ ªÙ  ¿ º¿ º  ¿ º¿ º  ¿ º,¿ º4   ¿ º_Q¿ ºd  ¿ ºw¿ º~   ¿ º¥x¿ ºπ  ¿ º–¿ º’  ¿ º‡¿ ºÁ  ¿ ºÚ¿ º˙   ¿ Ω0R¿ Ω5  ¿ Ω@¿ ΩG  ¿ ΩR¿ ΩZ   ¿ ΩÜÄƒ¿ ΩÚb/// Called when parser encounters a '!'
/// used as a non-null postfix assertion in an expression. ¿ æ
¿ æ   ¿ æNÄÕ¿ æœw/// Called after the parser has consumed a null-assert pattern, consisting of
/// a pattern followed by a `!` operator. ¿ æÁ
¿ æÓ   ¿ øÄŒ¿ øüv/// Called after the parser has consumed a null-check pattern, consisting of a
/// pattern followed by a `?` operator. ¿ ø∂¿ øΩ   ¿ øÒÅæ¿ ¡SÅP/// Called after the parser has consumed an assigned variable pattern,
/// consisting of a variable name identifier (other than `_`).
///
/// This method will only be called for a variable pattern that is part of a
/// `patternAssignment` (and hence should refer to a previously declared
/// variable rather than declaring a fresh one). ¿ ¡q¿ ¡x   ¿ ¡≥Ç√¿ √ﬂÇ/// Called after the parser has consumed a declared variable pattern,
/// consisting of an optional `var` or `final` keyword, an optional type
/// annotation, and a variable name identifier (other than `_`).
///
/// The flag [inAssignmentPattern] indicates whether this variable pattern is
/// part of a `patternAssignment`.  If this is `true`, it indicates that the
/// parser has recovered from an error (since declared variable patterns are
/// not allowed inside a `patternAssignment`).  The error has already been
/// reported. ¿ √˝¿ ƒ  ¿ ƒ¿ ƒ  ¿ ƒ$!¿ ƒ3   ¿ ƒzÅ¿ ≈3Ä≠/// Called after the parser has consumed a wildcard pattern, consisting of an
/// optional `var` or `final` keyword, an optional type annotation, and the
/// identifier `_`. ¿ ≈I¿ ≈Q  ¿ ≈Y¿ ≈`   ¿ ≈ì<¿ ≈ò  ¿ ≈•¿ ≈¨   ¿ ≈”*¿ ≈ÿ  ¿ ≈Ë¿ ≈Ô   ¿ ∆Å√¿ «FÅ-/// Handle the end of a record type declaration.
///
/// Substructures:
/// - RecordTypeEntry*
/// - RecordTypeNamedFields?
///
/// Notice that [count] is:
/// - the number of RecordTypeEntries if [hasNamedFields] is `false`, or
/// - the number of RecordTypeEntries + 1 if [hasNamedFields] is `true`. ¿ «[¿ «b  ¿ «n¿ «v  ¿ «É	¿ «à  ¿ «é¿ «î   ¿ «»¿ «Õ    ¿ «ÍÄΩ¿ »lp/// Handle the end of the record type entries.
///
/// Substructures:
/// - metadata
/// - type
/// - identifier   ¿ »´5¿ »∞  ¿ »À¿ »“   ¿ »‰Ä“¿ …Sa/// Handle the end of the record type named fields.
///
/// Substructures:
/// - RecordTypeEntry* ¿ …l	¿ …q  ¿ …w¿ …~   ¿ …∫+¿ …ø  ¿ …—¿ …ÿ   ¿ …ÈÄˇ¿  ãÄê/// Handle the end of a generic function type declaration.
///
/// Substructures:
/// - Type variables
/// - Return type
/// - Formal parameters ¿  õ¿  ¢  ¿  ∞¿  ∏   ¿  Ï'¿  Ò  ¿ À¿ À   ¿ Àg¿ À  ¿ À-	¿ À2  ¿ À8¿ À?  ¿ ÀJ¿ ÀQ   ¿ ÀÇÄ¡¿ Àıi/// After endTypeArguments has been called,
/// this event is called if those type arguments are invalid. ¿ Ã¿ Ã   ¿ ÃGN¿ ÃL  ¿ Ãb¿ Ãi   ¿ ÃôÄÆ¿ Õ&/// Handle the begin of a type formal parameter (e.g. "X extends Y").
/// Substructures:
/// - Metadata
/// - Name (identifier) ¿ Õ8¿ Õ?   ¿ ÕKÄ˚¿ ŒÄ∫/// Called when [beginTypeVariable] has been called for all of the variables
/// in a group, and before [endTypeVariable] has been called for any of the
/// variables in that same group. ¿ Œ,¿ Œ3  ¿ Œ9	¿ Œ>   ¿ ŒJÅû¿ œnÅ/// Handle the end of a type formal parameter (e.g. "X extends Y")
/// where [index] is the index of the type variable in the list of
/// type variables being declared.
///
/// Substructures:
/// - Type bound
///
/// See [beginTypeVariable] for additional substructures. ¿ œÖ¿ œå  ¿ œí	¿ œó  ¿ œù¿ œ•  ¿ œ¥¿ œº   ¿ œÏ'¿ œÒ  ¿ –¿ –   ¿ –\¿ –  ¿ –-¿ –4  ¿ –?¿ –F   ¿ –wÄØ¿ –|  ¿ –ù¿ –•   ¿ —*,¿ —/  ¿ —G¿ —N   ¿ —ZÅ¿ “
Äû/// Handle the end of a function expression (e.g. "() { ... }").
/// Substructures:
/// - Type variables
/// - Formal parameters
/// - Async marker
/// - Body ¿ “ ¿ “'  ¿ “2¿ “9   ¿ “oÄ¿¿ “’Z/// Handle the start of a variables declaration.  Substructures:
/// - Metadata
/// - Type ¿ “ˆ¿ “˝  ¿ ”¿ ”  ¿ ”¿ ”   ¿ ”3d¿ ”8  ¿ ”P	¿ ”U  ¿ ”[¿ ”c   ¿ ”õ(¿ ”†  ¿ ”¥¿ ”ª   ¿ ”«`¿ ”Ã  ¿ ”ﬁ¿ ”Â  ¿ ”Ú¿ ”˘   ¿ ‘++¿ ‘0  ¿ ‘D¿ ‘K   ¿ ‘ZL¿ ‘_  ¿ ‘q¿ ‘x   ¿ ‘™G¿ ‘Ø  ¿ ‘¿¿ ‘«   ¿ ‘ıÄ«¿ ’xy/// Called after the parser has consumed a cast pattern, consisting of a
/// pattern, `as` operator, and type annotation. ¿ ’ä¿ ’ë   ¿ ’¿X¿ ’≈  ¿ ’‡¿ ’Á   ¿ ÷Ä›¿ ÷‘Ä™/// Called when the parser encounters a binary operator, in between the LHS
/// and RHS subexpressions.
///
/// Not called when the binary operator is `.`, `?.`, or `..`. ¿ ÷Í¿ ÷Ò   ¿ ÷˝M¿ ◊  ¿ ◊¿ ◊   ¿ ◊Ns¿ ◊üI/// Called when the parser has consumed the operator of a binary pattern. ¿ ◊≤¿ ◊π   ¿ ◊≈Ä–¿ ÿSÄÑ/// Called when the parser has consumed a binary pattern, consisting of a LHS
/// pattern, `&&` or `||` operator, and a RHS pattern. ¿ ÿd¿ ÿk   ¿ ÿôÄ±¿ ÿ√"/// Called for `.`, `?.` and `..`. ¿ ÿ‡¿ ÿÁ   ¿ ŸNÄú¿ ŸΩe/// Called when the parser encounters a `?` operator and begins parsing a
/// conditional expression. ¿ Ÿÿ¿ Ÿﬂ   ¿ ŸÓÄÑ¿ ⁄MU/// Called when the parser encounters a `:` operator in a conditional
/// expression.   ¿ ⁄vÄ≤¿ ⁄∆H/// Called when the parser finishes processing a conditional expression. ¿ ⁄ﬂ¿ ⁄Ê  ¿ ⁄Ô¿ ⁄ˆ   ¿ €,0¿ €1  ¿ €F¿ €M   ¿ €`K¿ €e  ¿ €x¿ €   ¿ €ØO¿ €¥  ¿ €«¿ €Œ   ¿ ‹ÄÃ¿ ‹ïÄâ/// Called before parsing a "for" control flow list, set, or map entry.
/// Ended by either [endForControlFlow] or [endForInControlFlow]. ¿ ‹©¿ ‹±  ¿ ‹º¿ ‹√   ¿ ‹“ÄÌ¿ ›xÄö/// Called after parsing a "for" control flow list, set, or map entry.
/// One of the two possible corresponding end events for
/// [beginForControlFlow]. ¿ ›ä¿ ›ë   ¿ ›√ÄÙ¿ ﬁlÄù/// Called after parsing a "for-in" control flow list, set, or map entry.
/// One of the two possible corresponding end events for
/// [beginForControlFlow]. ¿ ﬁÄ¿ ﬁá   ¿ ﬁªÄ∑¿ ﬂNÄâ/// Called before parsing an `if` control flow list, set, or map entry.
/// Ended by either [endIfControlFlow] or [endIfElseControlFlow]. ¿ ﬂa¿ ﬂh   ¿ ﬂvÄê¿ ﬂ·a/// Called before parsing the `then` portion of an `if` control flow list,
/// set, or map entry. ¿ ﬂ˜¿ ﬂ˛   ¿ ‡
Ä∏¿ ‡ua/// Called before parsing the `else` portion of an `if` control flow list,
/// set, or map entry. ¿ ‡ã¿ ‡í   ¿ ‡∆Å4¿ ·µÄ›/// Called after parsing an `if` control flow list, set, or map entry.
/// Substructures:
/// - if conditional expression
/// - expression
/// One of the two possible corresponding end events for
/// [beginIfControlFlow]. ¿ ·∆¿ ·Õ   ¿ ·˛Å\¿ „Ä˚/// Called after parsing an if-else control flow list, set, or map entry.
/// Substructures:
/// - if conditional expression
/// - then expression
/// - else expression
/// One of the two possible corresponding end events for
/// [beginIfControlFlow]. ¿ „"¿ „)   ¿ „^Ä˙¿ ‰Äù/// Called after parsing a list, set, or map entry that starts with
/// one of the spread collection tokens `...` or `...?`.  Substructures:
/// - expression ¿ ‰¿ ‰%   ¿ ‰\Ä˛¿ ‰˚Äì/// Called after parsing an element of a list or map pattern that starts with
/// `...`.  Substructures:
/// - pattern (if hasSubPattern is `true`) ¿ Â
¿ Â  ¿ Â¿ Â)   ¿ Â^Äö¿ Â«_/// Handle the start of a function typed formal parameter.  Substructures:
/// - type variables ¿ ÂÈ¿ Â   ¿ Â¸Å
¿ ÊëÄá/// Handle the end of a function typed formal parameter.  Substructures:
/// - type variables
/// - return type
/// - formal parameters ¿ Ê±¿ Ê∏  ¿ Ê¬¿ Ê    ¿ Á
Ä”¿ ÁÉm/// Handle an identifier token.
///
/// [context] indicates what kind of construct the identifier appears in. ¿ Áî¿ Áõ  ¿ Á°¿ Á¥   ¿ Á·Äê¿ ÁÊ  ¿ Ë¿ Ë  ¿ Ë¿ Ë  ¿ Ë/¿ Ë6   ¿ Ëu+¿ Ëz  ¿ Ëé¿ Ëï   ¿ Ë§L¿ Ë©  ¿ Ëª¿ Ë¬   ¿ ËÙU¿ Ë˘  ¿ È
¿ È  ¿ È
¿ È$   ¿ ÈMF¿ ÈR  ¿ Èd¿ Èk   ¿ Èóz¿ Èú  ¿ È∏¿ Èæ  ¿ È»¿ Èœ  ¿ È‹¿ È„   ¿ ÍÄÉ¿ Í  ¿ Í9¿ Í?  ¿ ÍI¿ ÍP  ¿ Í`¿ Íg   ¿ ÍúL¿ Í°  ¿ Í∂¿ ÍΩ   ¿ ÍÏ5¿ ÍÒ  ¿ Í˝¿ Î  ¿ Î¿ Î   ¿ Î%Äé¿ Î*  ¿ Î4¿ Î;  ¿ ÎI¿ ÎQ  ¿ ÎV¿ Î]  ¿ Îs¿ Î{  ¿ ÎÜ¿ Îç   ¿ Î∑Ä«¿ Ï9z/** Called with either the token containing a double literal, or
    * an immediately preceding "unary plus" token.
    */ ¿ ÏM¿ ÏT   ¿ ÏÇÄ√¿ Ì|/** Called with either the token containing an integer literal,
    * or an immediately preceding "unary plus" token.
    */ ¿ Ì¿ Ì   ¿ ÌIÄá¿ ÌN  ¿ Ìg	¿ Ìl  ¿ Ìr¿ Ìy  ¿ ÌÖ¿ Ìç  ¿ Ìö¿ Ì°   ¿ Ì‘ÄÙ¿ ÓbÄÑ/// Called after the parser has consumed a list pattern, consisting of a `[`,
/// a comma-separated sequence of patterns, and a `]`. ¿ Ót	¿ Óy  ¿ Ó¿ ÓÜ  ¿ Óí¿ Óô   ¿ ÓÃÅW¿ Ó—  ¿ ÓÏ	¿ ÓÒ  ¿ Ó˚¿ Ô  ¿ Ô¿ Ô  ¿ Ô)¿ Ô0  ¿ ÔÁ¿ ÔÌ   ¿ 'ÄÙ¿ ªÄä/// Called after the parser has consumed a map pattern, consisting of a `{`,
/// a comma-separated sequence of mapPatternEntry, and a `}`. ¿ Ã	¿ —  ¿ ◊¿ ﬁ  ¿ Ë¿ Ô   ¿ ÒF¿ Ò$  ¿ Ò6¿ Ò=   ¿ Òi\¿ Òn  ¿ ÒÅ¿ Òà  ¿ Òî¿ Òö   ¿ Ò…J¿ ÒŒ  ¿ Ò‚¿ ÒÈ   ¿ ÚÄÕ¿ Ú†/// Called after the parser has consumed a patternField, consisting of an
/// optional identifier, optional `:`, and a pattern. ¿ Ú≥¿ Úª   ¿ ÚËP¿ ÚÌ  ¿ Û¿ Û   ¿ Û<'¿ ÛA  ¿ ÛT¿ Û[   ¿ ÛgG¿ Ûl  ¿ Û}¿ ÛÑ   ¿ Û≤F¿ Û∑  ¿ Û…¿ Û–   ¿ Û¸Äò¿ Ù  ¿ Ù<¿ ÙC   ¿ Ùòp¿ Ùù  ¿ Ùƒ¿ ÙÀ   ¿ ıC¿ ı  ¿ ı¿ ı%   ¿ ıSN¿ ıX  ¿ ın¿ ıu   ¿ ı•@¿ ı™  ¿ ıπ¿ ı¿   ¿ ıÈÄ§¿ ˆ6E/// Invoked when a pattern switch case doesn't have the 'when' clause ¿ ˆS¿ ˆZ   ¿ ˆëf¿ ˆñ  ¿ ˆ∏¿ ˆø   ¿ ˆ˚D¿ ˜   ¿ ˜¿ ˜   ¿ ˜CÄ£¿ ˜åA/// Handle the end of a construct of the form "operator <token>". ¿ ˜ü¿ ˜¶  ¿ ˜∂¿ ˜Ω   ¿ ˜ÍÄ„¿ ¯eq/// Handle the end of a construct of the form "operator <token>"
/// where <token> is not a valid operator token. ¿ ¯¿ ¯Ü  ¿ ¯ñ¿ ¯ù   ¿ ¯—Å¿ ˘`/// Handle the condition in a control structure:
/// - if statement
/// - do while loop
/// - switch statement
/// - while loop ¿ ˘}¿ ˘Ñ  ¿ ˘ä¿ ˘í  ¿ ˘ò¿ ˘†   ¿ ˘÷T¿ ˘Ú/// Starts a pattern ¿ ˘ˇ¿ ˙   ¿ ˙.Äì¿ ˙ÄJ/// Starts a pattern guard, the expression that follows the 'when' keyword ¿ ˙í
¿ ˙ô   ¿ ˙≈Ä—¿ ˚[Äå/// Starts a parenthesized expression or a record literal. Will be ended with
/// either [endParenthesizedExpression] or [endRecordLiteral]. ¿ ˚á¿ ˚é   ¿ ˚öÄ°¿ ˚ÍH/// Starts a guard expression in a switch case, after the 'when' keyword ¿ ¸
¿ ¸   ¿ ¸?Äô¿ ¸v//// Ends a record literal with [count] entries. ¿ ¸á¿ ¸é  ¿ ¸î	¿ ¸ô  ¿ ¸ü¿ ¸ß   ¿ ¸‹ÄÂ¿ ˝qÄã/// Called after the parser has consumed a record pattern, consisting of a
/// `(`, a comma-separated sequence of patternFields, and a `)`. ¿ ˝Ö¿ ˝å  ¿ ˝í	¿ ˝ó   ¿ ˝≈P¿ ˝ﬂ/// Ends a pattern ¿ ˝Í¿ ˝Ò   ¿ ˛Äè¿ ˛hG/// End a pattern guard, the expression that follows the 'when' keyword ¿ ˛x¿ ˛   ¿ ˛¨Å¿ ˇ]Ä•/// End a parenthesized expression.
/// These may be within the condition expression of a control structure
/// but will not be the condition of a control structure. ¿ ˇx¿ ˇ   ¿ ˇ∑Ä†¿ H/// Starts a guard expression in a switch case, after the 'when' keyword ¿ ¿ &   ¿ [ÄÕ¿ ’p/// Called after the parser has consumed a parenthesized pattern, consisting
/// of a `(`, a pattern, and a `)`. ¿ ¿ ˜   ¿,ÇÆ¿äÇD/// Called after the parser has consumed a constant pattern, consisting of an
/// optional `const` and an expression.
///
/// Note that some expressions can legally begin with `const`, so there is
/// ambiguity as to whether to associate the `const` keyword with the constant
/// pattern or the constant expression.  This ambiguity is resolved in favor
/// of associating the `const` keyword with the constant pattern.  So for
/// example, in `case const []` the `const` keyword is passed to
/// [beginConstantPattern] and [endConstantPattern] rather than
/// [handleLiteralList]. ¿ü¿ß   ¿ﬁÇ¨¿<ÇD/// Called after the parser has consumed a constant pattern, consisting of an
/// optional `const` and an expression.
///
/// Note that some expressions can legally begin with `const`, so there is
/// ambiguity as to whether to associate the `const` keyword with the constant
/// pattern or the constant expression.  This ambiguity is resolved in favor
/// of associating the `const` keyword with the constant pattern.  So for
/// example, in `case const []` the `const` keyword is passed to
/// [beginConstantPattern] and [endConstantPattern] rather than
/// [handleLiteralList]. ¿O¿W   ¿éÅ¿íÄˆ/// Called after the parser has consumed an object pattern, consisting of
/// an identifier, optional dot and second identifier, optional type
/// arguments, and a parenthesized list of object pattern fields (see
/// [handleObjectPatternFields]). ¿≠¿¥  ¿ƒ
¿Ã  ¿–¿ÿ   ¿ÅC¿	Äı/// Handle a construct of the form "identifier.identifier" occurring in a part
/// of the grammar where expressions in general are not allowed.
/// Substructures:
/// - Qualified identifier (before the period)
/// - Identifier (after the period) ¿	&¿	-   ¿	XD¿	]  ¿	n¿	u   ¿	†i¿	•  ¿	ª¿	¬  ¿	»¿	€   ¿
Äó¿
  ¿
6¿
=  ¿
J¿
Q  ¿
\¿
o   ¿
®N¿
≠  ¿
Ω¿
¬  ¿
Õ¿
“  ¿
‚¿
È   ¿
˙ÄÎ¿
ˇ  ¿¿  ¿*¿/  ¿E¿M  ¿b¿j  ¿Ç¿á  ¿ú¿£  ¿¥¿ª   ¿È#¿Ó    ¿r¿  ¿-¿5  ¿:¿A  ¿G¿N   ¿Üg¿ã  ¿†¿ß  ¿≠¿¿   ¿Òp¿ˆ  ¿¿$   ¿eZ¿j  ¿Ü¿ç   ¿√ÄÔ¿eÄò/// Called after the parser has consumed a relational pattern, consisting of
/// an equality operator or relational operator, followed by an expression. ¿}¿Ñ   ¿∂n¿ª  ¿·¿Ë   ¿(4¿-    ¿`l¿e    ¿–Äâ¿’  ¿¯¿ˇ  ¿¿  ¿¿(   ¿]f¿b  ¿Ñ¿ã   ¿«F¿Ã  ¿ﬁ¿Â   ¿ÄÌ¿ïz/// The parser saw a void with type arguments (e.g. void<int>).
/// This is not valid - an error has already been emitted. ¿∏¿ø   ¿q¿PF/// Ended by either [endYieldStatement] or [endInvalidYieldStatement]. ¿d¿k   ¿wÄ»¿‘S/// One of the two possible corresponding end events for
/// [beginYieldStatement]. ¿Ê¿Ì  ¿¯¿   ¿
¿   ¿CÄÛ¿†S/// One of the two possible corresponding end events for
/// [beginYieldStatement]. ¿π¿¿  ¿À¿”  ¿„¿Í  ¿Û¿    ¿:Åâ¿pÅ(/// The parser noticed a syntax error, but was able to recover from it. The
/// error should be reported using the [message], and the code between the
/// beginning of the [startToken] and the end of the [endToken] should be
/// highlighted. The [startToken] and [endToken] can be the same token. ¿é¿ó  ¿ü¿¶  ¿±¿∏   ¿«ÇG¿5Å^/// The parser noticed a use of the experimental feature by the flag
/// [experimentalFlag] that was not enabled, but was able to recover from it.
/// The error should be reported and the code between the beginning of the
/// [startToken] and the end of the [endToken] should be highlighted. The
/// [startToken] and [endToken] can be the same token. ¿W!¿i  ¿z¿Å  ¿å¿ì   ¿Åf¿ÄÓ/// The parser encountered an [ErrorToken] representing an error
/// from the scanner but recovered from it. By default, the error is reported
/// by calling [handleRecoverableError] with the message associated
/// with the error [token]. ¿¿+   ¿|Ä©¿ç  ¿®¿±  ¿π¿¿  ¿…¿Œ  ¿€
¿‡  ¿|¿}¿)Å™¿fÅ//// Signals to the listener that the previous statement contained a semantic
/// error (described by the given [message]). This method can also be called
/// after [handleExpressionFunctionBody], in which case it signals that the
/// implicit return statement of the function contained a semantic error. ¿}¿Ñ  ¿ä¿ì   ¿◊<¿‹  ¿È¿   ¿É9¿Ç·/// An expression was encountered consisting of type arguments applied to a
/// subexpression.  This could validly represent any of the following:
/// - A type literal (`var x = List<int>;`)
/// - A function tear-off with type arguments (`var x = f<int>;` or
///   `var x = importPrefix.f<int>;`)
/// - A static method tear-off with type arguments (`var x = ClassName.m<int>`
///   or `var x = importPrefix.ClassName.m<int>;`)
/// - An instance method tear-off with type arguments (`var x = EXPR.m<int>;`)
///
/// Or, in the event of invalid code, it could represent type arguments
/// erroneously applied to some other expression type (e.g.
/// `var x = (f)<int>;`).  The client is responsible for reporting an error if
/// this occurs. ¿6¿=   ¿TÅV¿ ÖÅ#/// A `new` token was found in a place where an identifier was expected, and
/// the "constructor tearoffs" feature permits `new` to be used as an
/// identifier name.  It is the client's responsibility to report an
/// appropriate error if the "constructor tearoffs" feature is not enabled. ¿ õ¿ ¢   ¿ ÆÅÍ¿!ˇÅ?/// Called after the parser has processed a variable declaration statement,
/// consisting of `METADATA KEYWORD PATTERN EQUALS EXPRESSION SEMICOLON`.
///
/// KEYWORD is either `var` or `final`, and PATTERN may only be one of the
/// patterns accepted by the `outerPattern` grammar rule defined in the
/// patterns spec. ¿"0¿"7  ¿"?¿"F  ¿"M¿"T   ¿"úÅI¿#óÄÎ/// Called after the parser has processed a pattern assignment consisting of
/// `PATTERN EQUALS EXPRESSION`.
///
/// PATTERN may only be one of the patterns accepted by the `outerPattern`
/// grammar rule defined in the patterns spec. ¿#Ø¿#∂                #_fe_analyzer_shared.parser.listenerâ NÄúÄÿÄŸÅÅÅ,ÅPÅãÅåÅ∑Å∏ÅÓÅÔÇÇÇ;Ç<ÇäÇãÇ…Ç ÉÉÉPÉQÉ|É}É§É¿ÑÑÑÑMÑcÑgÑ≥Ñ∑Ñ˝ÖMÖcÖgÖ∂Ö¡ÖÛÜÜÜ,Ü-ÜSÜTÜóÜ≤Ü∂Ü∑áá1áÅá¶á™á´á„à%àDàHàIàîà¿à¡à¸ââXâyâ}â~âπâ◊â˘ä:äbäfägäûäüä∞ä˙ãããã`ãûã¨ãﬁãﬂåååå3å7å8åiåjå≤å“å÷å◊ç%çpç~çÃçÕéébéhé•éÃèèJèNèOèúèµèªêêEêcêiêíêŸê⁄ëëPëöë†ëÌííí:íSímíÖí¢íªí÷íÔìììKìzìÀîî&îhîÜîäîãî‘îÈïïLïhïlïmï≠ïæï–ï„ï˙ññ ñ:ñPñ†ñΩñ¡ñ¬ó
óLóäó≤óÊó¯òò&òjòîòòòôò÷òÎò˛ô=ô_ôcôdôóô€öööXörö™ö√ö«ö»õõõ,õCõTõnõùõ∫õæõøõıú7úuú∑úÍú˚ùù7ùKùoùìùóùòù’ùÍûûEûgûkûlû™û∞ûŸüüügüxü~üÃ†††H†ã†å†‹†Û†˘°F°h°´°¨°ˆ¢-¢=¢J¢ì¢Ω¢„¢Á¢Ë£5£L£R£ü£≈§	§
§T§è§≥§Õ§⁄•$•g•ë•ï•ñ•‚¶¶E¶i¶m¶n¶∏ßß$ß*ßZß`ßuß≤ß¬ß‡®(®L®P®Q®†®–©©©@©A©d©Å©Ö©Ü©≤©≥©Ï™3™9™™¿™—™Ú™Û´'´H´L´M´v´w´†´æ´¬´√´Ù´ı¨:¨ã¨±¨µ¨∂¨„¨‰≠ ≠=≠_≠c≠d≠ï≠ñ≠ƒ≠Í≠Ó≠ÔÆÆÆNÆrÆvÆwÆûÆüÆ‹Æ˘ØØTØ}ØìØóØòØ·ØÚ∞∞;∞R∞l∞Å∞ñ∞£∞Ú±$±d±x±¿±ƒ±≈±Ù≤≤*≤q≤è≤ì≤î≤‘≤Â≥≥≥/≥I≥b≥£≥ø≥√≥ƒ≥Ú¥¥#¥e¥Ç¥Ü¥á¥§¥‰µ%µ)µ*µMµNµãµúµ®µ¡µ’∂∂&∂*∂+∂t∂√∂Á∑)∑O∑S∑T∑Ñ∑©∑≠∑Æ∑Ë∏&∏u∏ß∏®∏∆ππ*π.π/πMπçπÕ∫∫∫∫5∫u∫µ∫ˆ∫˙∫˚ª!ªaª°ª‚ªÊªÁº7ºoºpºãº•º¿ºÂº¸ΩΩ8ΩXΩwΩòΩúΩùΩ›ææææDæEæaæßæ…æÕæŒøø"ø4øAømøsøìø™ø∆ø·ø˝¿ @¿ @4¿ @L¿ @j¿ @{¿ @ì¿ @´¿ @√¿ @«¿ @»¿ A¿ A¿ A.¿ A;¿ Ag¿ Am¿ Aç¿ A§¿ A¿¿ A€¿ A˜¿ B¿ B.¿ BF¿ Bd¿ Bu¿ Bç¿ B•¿ BÂ¿ B˘¿ C¿ C&¿ C=¿ CR¿ Cj¿ C}¿ Cñ¿ C•¿ Cπ¿ CÃ¿ C–¿ C—¿ D¿ D)¿ D;¿ DH¿ Dt¿ Dz¿ Dö¿ Dµ¿ D—¿ DÏ¿ E¿ E"¿ E?¿ EW¿ Eu¿ EÜ¿ Eû¿ E∂¿ Eˆ¿ F
¿ F!¿ F7¿ FN¿ Fc¿ F{¿ Fé¿ Fß¿ F∂¿ F ¿ F›¿ F·¿ F‚¿ G.¿ G?¿ GQ¿ G^¿ Gä¿ Gê¿ G∞¿ Gœ¿ GÎ¿ H¿ H"¿ H<¿ HY¿ Hq¿ Hè¿ H†¿ H∏¿ H–¿ I¿ I$¿ I;¿ IQ¿ Ih¿ I}¿ Iï¿ I®¿ I¡¿ I–¿ I‰¿ I˜¿ I˚¿ I¸¿ J?¿ JP¿ Jb¿ Jo¿ Jõ¿ J°¿ J¡¿ J◊¿ JÛ¿ K¿ K*¿ KD¿ Ka¿ Ky¿ Kó¿ K®¿ K¿¿ Kÿ¿ KÏ¿ L¿ L¿ L0¿ LE¿ L]¿ Lp¿ Lâ¿ Lò¿ L¨¿ Lø¿ L√¿ Lƒ¿ M¿ M¿ M-¿ Mb¿ My¿ Mì¿ M®¿ MΩ¿ M ¿ N¿ NF¿ NZ¿ N¢¿ N¶¿ Nß¿ N˜¿ O¿ OQ¿ O¿ OÉ¿ OÑ¿ O‘¿ O˙¿ PD¿ Pw¿ P{¿ P|¿ PÃ¿ Q¿ Q7¿ QÜ¿ Qæ¿ Q¬¿ Q√¿ R¿ RI¿ Rz¿ R∞¿ R’¿ S¿ S¿ S¿ S[¿ SÇ¿ S´¿ S¨¿ SÙ¿ TA¿ T¿ Tº¿ Tı¿ Tˆ¿ U¿ U=¿ UA¿ UB¿ Uo¿ Up¿ Uù¿ Uø¿ U√¿ Uƒ¿ V¿ V\¿ Vñ¿ VÕ¿ W¿ W<¿ Ww¿ W∂¿ W˛¿ Wˇ¿ XN¿ Xp¿ Xá¿ Xã¿ Xå¿ X∏¿ Xπ¿ X‚¿ Y¿ Y¿ Y¿ Y.¿ Y/¿ YU¿ Yp¿ Yt¿ Yu¿ Y¡¿ Z¿ Z_¿ Z•¿ Z´¿ Z¿¿ Z◊¿ [¿ [¿ [P¿ [ö¿ [Ê¿ \#¿ \)¿ \>¿ \U¿ \g¿ \{¿ \à¿ \ò¿ \≠¿ \ƒ¿ \˜¿ ]+¿ ]T¿ ]X¿ ]Y¿ ]•¿ ]∂¿ ]Õ¿ ^¿ ^¿ ^!¿ ^'¿ ^<¿ ^M¿ ^d¿ ^x¿ ^Ö¿ ^ú¿ ^¨¿ ^¡¿ ^ÿ¿ _¿ _@¿ _e¿ _i¿ _j¿ _≤¿ `¿ `P¿ `z¿ `®¿ `©¿ `ˆ¿ a?¿ aé¿ a‹¿ b#¿ bW¿ b¢¿ b≈¿ b…¿ b ¿ bı¿ c¿ c¿ c¿ cb¿ ch¿ c∂¿ c⁄¿ d"¿ d#¿ dL¿ dM¿ dÖ¿ d£¿ dß¿ d®¿ dÃ¿ dÕ¿ d¸¿ e¿ eG¿ eX¿ el¿ eÜ¿ e£¿ eΩ¿ e√¿ f¿ f¿ f8¿ fU¿ f{¿ f«¿ fﬂ¿ g¿ g¿ g¿ gG¿ g\¿ g{¿ g≠¿ gŒ¿ g“¿ g”¿ h¿ h'¿ hJ¿ hN¿ hO¿ hè¿ h§¿ h√¿ h…¿ i¿ iF¿ iw¿ ió¿ iõ¿ iú¿ iÕ¿ iÔ¿ j¿ j¿ j¿ jV¿ jk¿ jä¿ jê¿ j–¿ k¿ k8¿ kY¿ k]¿ k^¿ kó¿ kﬂ¿ l)¿ l/¿ l|¿ lü¿ l∑¿ l”¿ lÏ¿ m¿ m¿ m;¿ mT¿ mo¿ mà¿ mù¿ mû¿ mÁ¿ m¸¿ n¿ n-¿ no¿ n†¿ n§¿ n•¿ nË¿ n˘¿ o¿ o¿ o5¿ oG¿ o[¿ oÄ¿ oÜ¿ oŒ¿ p¿ pk¿ p´¿ p±¿ pÙ¿ qC¿ qu¿ qú¿ q†¿ q°¿ q»¿ q…¿ r¿ r,¿ rP¿ rf¿ rj¿ rk¿ rî¿ r¥¿ r∏¿ rπ¿ rﬁ¿ rﬂ¿ rˇ¿ s¿ s¿ s¿ sF¿ sG¿ sÄ¿ sù¿ s°¿ s¢¿ sÃ¿ sÕ¿ sÙ¿ t¿ t¿ t¿ tB¿ tC¿ tj¿ tâ¿ tç¿ té¿ tπ¿ t∫¿ u ¿ u?¿ uq¿ uß¿ uÌ¿ v¿ v¿ v¿ vM¿ v^¿ vj¿ vÉ¿ vù¿ v±¿ w ¿ w¿ w¿ w¿ wX¿ wí¿ w‘¿ x"¿ x;¿ xU¿ xi¿ xò¿ x∏¿ xº¿ xΩ¿ xÈ¿ xÍ¿ y¿ y2¿ y6¿ y7¿ yf¿ yg¿ y¨¿ y¿¿ z ¿ z¿ zl¿ zå¿ zê¿ zë¿ zÕ¿ zÈ¿ zÌ¿ zÓ¿ {%¿ {&¿ {r¿ {û¿ {¢¿ {£¿ {’¿ {÷¿ |	¿ |0¿ |4¿ |5¿ |b¿ |c¿ |†¿ |ø¿ |˛¿ } ¿ }$¿ }%¿ }S¿ }Ç¿ }¶¿ }™¿ }´¿ }€¿ }‹¿ ~¿ ~;¿ ~u¿ ~ö¿ ~û¿ ~ü¿ ~Œ¿  ¿ '¿ +¿ ,¿ T¿ U¿ }¿ •¿ ©¿ ™¿ ”¿ ‘¿ Ä¿ Ä8¿ Ä<¿ Ä=¿ Ä]¿ Ä}¿ ÄÅ¿ ÄÇ¿ Ä–¿ Å¿ ÅB¿ Åp¿ Åì¿ Åó¿ Åò¿ Åﬂ¿ Ç/¿ Çi¿ Çô¿ Çæ¿ Ç¬¿ Ç√¿ É¿ É\¿ Ék¿ Éú¿ É¬¿ É∆¿ É«¿ ÉÈ¿ Ñ ¿ Ñ¿ Ñ¿ ÑB¿ ÑC¿ Ñp¿ Ñí¿ Ññ¿ Ñó¿ ÑÊ¿ ÑÁ¿ Ö1¿ ÖB¿ ÖN¿ Öm¿ Ö≤¿ Ö◊¿ Ö€¿ Ö‹¿ Ü¿ Ü¿ ÜB¿ ÜS¿ ÜÅ¿ ÜŒ¿ ÜÎ¿ ÜÔ¿ Ü¿ á,¿ áM¿ áQ¿ áR¿ á°¿ áÀ¿ à¿ à(¿ à,¿ à-¿ àW¿ àX¿ à®¿ à©¿ àÎ¿ â
¿ â¿ â¿ âV¿ â{¿ â¿ âÄ¿ âœ¿ ä¿ äW¿ äz¿ äí¿ äì¿ äŒ¿ äﬂ¿ ã¿ ã+¿ ã/¿ ã0¿ ãk¿ ã®¿ ãæ¿ ã¿ å0¿ åp¿ å§¿ å–¿ åÂ¿ å˝¿ ç¿ ç¿ çQ¿ çb¿ çÆ¿ ç˛¿ é¿ é*¿ éQ¿ él¿ éà¿ é¢¿ éø¿ é›¿ éÙ¿ è	¿ è
¿ èN¿ è_¿ ès¿ è®¿ èø¿ èŸ¿ èÓ¿ ê¿ ê¿ ê[¿ êç¿ ê™¿ êÆ¿ êØ¿ êÛ¿ ë¿ ë¿ ëM¿ ëd¿ ë~¿ ëì¿ ë®¿ ëµ¿ í ¿ í2¿ ír¿ íÜ¿ íŒ¿ í“¿ í”¿ ì¿ ì,¿ ì@¿ ìu¿ ìå¿ ì¶¿ ìª¿ ì–¿ ì›¿ î,¿ î^¿ îû¿ î≤¿ î˙¿ î˛¿ îˇ¿ ïL¿ ï]¿ ïq¿ ï¶¿ ïΩ¿ ï◊¿ ïÏ¿ ñ¿ ñ¿ ñO¿ ñì¿ ñ”¿ ñÁ¿ ó/¿ ó3¿ ó4¿ ó}¿ óé¿ ó¢¿ ó◊¿ óÓ¿ ò¿ ò¿ ò2¿ ò?¿ òè¿ ò¡¿ ô¿ ô¿ ô]¿ ôa¿ ôb¿ ô´¿ ôº¿ ô–¿ ö¿ ö¿ ö6¿ öK¿ ö`¿ öm¿ öΩ¿ öÔ¿ õ/¿ õC¿ õã¿ õè¿ õê¿ õ›¿ õÓ¿ ú¿ ú7¿ úN¿ úh¿ ú}¿ úí¿ úü¿ ú·¿ ù%¿ ùe¿ ùy¿ ù¡¿ ù≈¿ ù∆¿ û	¿ û¿ û/¿ ûC¿ ûx¿ ûè¿ û©¿ ûæ¿ û”¿ û‡¿ ü&¿ üj¿ ü™¿ ü√¿ †¿ †¿ †¿ †9¿ †:¿ †^¿ †|¿ †Ä¿ †Å¿ †¶¿ †ß¿ †Ê¿ †˘¿ °¿ °T¿ °f¿ °∂¿ °–¿ °‘¿ °’¿ ¢
¿ ¢¿ ¢/¿ ¢d¿ ¢é¿ ¢í¿ ¢ì¿ ¢¥¿ ¢µ¿ ¢Ô¿ £ ¿ £¿ £A¿ £W¿ £[¿ £\¿ £¿ £Ä¿ £ø¿ £–¿ £˛¿ §¿ §T¿ §b¿ §t¿ §ø¿ §◊¿ §€¿ §‹¿ •¿ •¿ •U¿ •}¿ •Å¿ •Ç¿ •Æ¿ •Ø¿ •‹¿ ¶¿ ¶d¿ ¶à¿ ¶å¿ ¶ç¿ ¶⁄¿ ß¿ ß^¿ ßu¿ ß¬¿ ßÌ¿ ßÒ¿ ßÚ¿ ®>¿ ®Ä¿ ®Õ¿ ®¯¿ ®¸¿ ®˝¿ ©>¿ ©p¿ ©ì¿ ©ó¿ ©ò¿ ©‰¿ ™¿ ™_¿ ™á¿ ™ã¿ ™å¿ ™ß¿ ™Â¿ ´¿ ´
¿ ´¿ ´A¿ ´W¿ ´[¿ ´\¿ ´É¿ ´Ñ¿ ´¡¿ ´Ê¿ ¨
¿ ¨ ¿ ¨$¿ ¨%¿ ¨Q¿ ¨R¿ ¨ì¿ ¨¥¿ ¨∏¿ ¨π¿ ¨Ê¿ ¨Á¿ ≠)¿ ≠K¿ ≠O¿ ≠P¿ ≠x¿ ≠y¿ ≠¬¿ ≠ﬂ¿ ≠„¿ ≠‰¿ Æ¿ Æ¿ Æ8¿ Æq¿ Æò¿ Æú¿ Æù¿ Æ«¿ Æ»¿ Ø¿ Ø'¿ Ø+¿ Ø,¿ Øm¿ Øé¿ Øí¿ Øì¿ Ø¿¿ Ø¡¿ ∞¿ ∞$¿ ∞(¿ ∞)¿ ∞e¿ ∞µ¿ ∞ˇ¿ ± ¿ ±&¿ ±X¿ ±ú¿ ±‹¿ ≤&¿ ≤5¿ ≤;¿ ≤w¿ ≤∆¿ ≤¯¿ ≥(¿ ≥M¿ ≥Q¿ ≥R¿ ≥ö¿ ≥„¿ ¥"¿ ¥U¿ ¥[¿ ¥p¿ ¥Å¿ ¥ª¿ ¥Á¿ ¥Î¿ ¥Ï¿ µ2¿ µn¿ µt¿ µù¿ µ»¿ µ…¿ µ¸¿ ∂F¿ ∂v¿ ∂ä¿ ∂±¿ ∂Õ¿ ∂Ë¿ ∑¿ ∑¿ ∑;¿ ∑S¿ ∑q¿ ∑é¿ ∑è¿ ∑Ÿ¿ ∑Í¿ ∑˜¿ ∏¿ ∏<¿ ∏X¿ ∏^¿ ∏~¿ ∏ò¿ ∏≥¿ ∏œ¿ ∏È¿ π¿ π¿ π<¿ πM¿ πe¿ π}¿ πù¿ π°¿ π¢¿ πæ¿ ∫¿ ∫¿ ∫C¿ ∫T¿ ∫f¿ ∫z¿ ∫ç¿ ∫§¿ ∫æ¿ ∫”¿ ∫‡¿ ª.¿ ªN¿ ªR¿ ªS¿ ª|¿ ª}¿ ª•¿ ª¶¿ ªÀ¿ ªË¿ ªÏ¿ ªÌ¿ º<¿ ºX¿ º\¿ º]¿ ºè¿ º≠¿ º±¿ º≤¿ º ¿ Ω¿ Ω)¿ Ω-¿ Ω.¿ Ωi¿ Ω¿ ΩÉ¿ ΩÑ¿ ΩÆ¿ ΩÎ¿ æ¿ æG¿ æK¿ æL¿ æú¿ æ»¿ æı¿ ø¿ ø¿ ø¿ øn¿ øò¿ ø»¿ øÍ¿ øÓ¿ øÔ¿ ¿8¿ ¿y¿ ¿¿ ¿Œ¿ ¡¿ ¡L¿ ¡É¿ ¡¨¿ ¡∞¿ ¡±¿ ¡˘¿ ¬D¿ ¬á¿ ¬ç¿ ¬›¿ √,¿ √{¿ √»¿ √ÿ¿ ƒ¿ ƒJ¿ ƒs¿ ƒw¿ ƒx¿ ƒ»¿ ≈¿ ≈,¿ ≈k¿ ≈å¿ ≈ê¿ ≈ë¿ ≈¥¿ ≈Ã¿ ≈–¿ ≈—¿ ≈˛¿ ≈ˇ¿ ∆2¿ ∆8¿ ∆M¿ ∆f¿ ∆Ö¿ ∆ã¿ ∆©¿ ∆Ù¿ «?¿ «U¿ «•¿ «¡¿ «≈¿ «∆¿ «Á¿ «Ë¿ »¿ »¿ »4¿ »E¿ »R¿ »e¿ »É¿ »§¿ »®¿ »©¿ »·¿ »‚¿ …¿ …¿ …3¿ …L¿ …å¿ …≥¿ …∑¿ …∏¿ …Ê¿ …Á¿  $¿  *¿  ?¿  V¿  j¿  Ñ¿  «¿  Â¿  È¿  Í¿ À¿ À¿ À\¿ À{¿ À¿ ÀÄ¿ ÀÆ¿ ÀÓ¿ Ã¿ Ã@¿ ÃD¿ ÃE¿ Ãq¿ Ãí¿ Ãñ¿ Ãó¿ Ãﬂ¿ ÃÙ¿ Õ¿ Õ¿ ÕH¿ ÕI¿ Õò¿ ÕÊ¿ Œ
¿ ŒG¿ ŒH¿ Œç¿ Œ“¿ Œ˜¿ Œ˝¿ œ¿ œ%¿ œ+¿ œg¿ œ¿ œ«¿ œÂ¿ œÈ¿ œÍ¿ –¿ –¿ –Q¿ –p¿ –t¿ –u¿ –∞¿ –Ã¿ —¿ —#¿ —'¿ —(¿ —W¿ —X¿ —õ¿ —∞¿ —«¿ —·¿ —ˆ¿ “¿ “D¿ “h¿ “l¿ “m¿ “∞¿ “¡¿ “Œ¿ “¿ ”0¿ ”1¿ ”n¿ ”î¿ ”ò¿ ”ô¿ ”ƒ¿ ”≈¿ ‘¿ ‘$¿ ‘(¿ ‘)¿ ‘W¿ ‘X¿ ‘É¿ ‘£¿ ‘ß¿ ‘®¿ ‘“¿ ‘Ó¿ ‘Ú¿ ‘Û¿ ’>¿ ’q¿ ’ú¿ ’π¿ ’Ω¿ ’æ¿ ’Ô¿ ÷¿ ÷¿ ÷¿ ÷h¿ ÷Ü¿ ÷å¿ ÷Õ¿ ÷˙¿ ÷˚¿ ◊%¿ ◊G¿ ◊K¿ ◊L¿ ◊ò¿ ◊¬¿ ◊√¿ ÿ¿ ÿL¿ ÿs¿ ÿí¿ ÿñ¿ ÿó¿ ÿº¿ ÿÔ¿ Ÿ'¿ ŸG¿ ŸK¿ ŸL¿ Ÿò¿ Ÿ∂¿ ŸÎ¿ ŸÏ¿ ⁄4¿ ⁄F¿ ⁄s¿ ⁄t¿ ⁄ø¿ ⁄˛¿ €%¿ €)¿ €*¿ €]¿ €^¿ €á¿ €®¿ €¨¿ €≠¿ €›¿ €˚¿ €ˇ¿ ‹ ¿ ‹J¿ ‹é¿ ‹œ¿ ‹–¿ ›¿ ›T¿ ›q¿ ›ô¿ ›º¿ ›¿¿ ›¡¿ ﬁ¿ ﬁH¿ ﬁe¿ ﬁè¿ ﬁ¥¿ ﬁ∏¿ ﬁπ¿ ﬂ¿ ﬂG¿ ﬂs¿ ﬂt¿ ﬂ¡¿ ﬂ⁄¿ ‡¿ ‡¿ ‡U¿ ‡n¿ ‡û¿ ‡ø¿ ‡√¿ ‡ƒ¿ ·¿ ·"¿ ·D¿ ·W¿ ·í¿ ·Æ¿ ·’¿ ·˜¿ ·˚¿ ·¸¿ ‚H¿ ‚]¿ ‚¿ ‚ó¿ ‚Ø¿ ‚Í¿ „¿ „1¿ „W¿ „[¿ „\¿ „¢¿ „Ì¿ ‰ ¿ ‰3¿ ‰U¿ ‰Y¿ ‰Z¿ ‰™¿ ‰«¿ ‰Ù¿ Â:¿ ÂW¿ Â[¿ Â\¿ Â©¿ Â¿¿ Â˘¿ Â˙¿ ÊE¿ Ê\¿ Êp¿ Êä¿ Ê’¿ Á¿ Á¿ Á¿ Á*¿ Á0¿ Á|¿ Áæ¿ Á⁄¿ Áﬁ¿ Áﬂ¿ Áˇ¿ ËK¿ Ën¿ Ër¿ Ës¿ Ë°¿ Ë¢¿ ËÕ¿ ËÌ¿ ËÒ¿ ËÚ¿ È*¿ ÈF¿ ÈJ¿ ÈK¿ Ès¿ Èê¿ Èî¿ Èï¿ È≤¿ ÈÓ¿ Í¿ Í¿ Í¿ Í3¿ Ír¿ Íï¿ Íô¿ Íö¿ Í≈¿ ÍÂ¿ ÍÈ¿ ÍÍ¿ Î"¿ Î#¿ Îm¿ Îò¿ Î∞¿ Î¥¿ Îµ¿ Î¯¿ Ï+¿ Ï2¿ Ï\¿ Ï{¿ Ï¿ ÏÄ¿ Ï¬¿ Ï¯¿ Ïˇ¿ Ì&¿ ÌB¿ ÌF¿ ÌG¿ Ìa¿ Ì∞¿ ÌÕ¿ Ì—¿ Ì“¿ Ó"¿ Ó[¿ Ó®¿ Ó≈¿ Ó…¿ Ó ¿ ÓË¿ Ó˜¿ Ô¿ Ô%¿ Ô;¿ ÔÑ¿ Ô”¿ Ô„¿ Ô˘¿ Ôˇ¿  ¿ $¿ %¿ t¿ ¥¿ ¸¿ Ò¿ Ò¿ Ò¿ ÒE¿ Òb¿ Òf¿ Òg¿ Ò§¿ Ò¬¿ Ò∆¿ Ò«¿ ÒÒ¿ Ú¿ Ú¿ Ú¿ Úa¿ Úô¿ Ú√¿ Ú·¿ ÚÂ¿ ÚÊ¿ Û¿ Û5¿ Û9¿ Û:¿ Ûd¿ Ûe¿ Ûå¿ Û´¿ ÛØ¿ Û∞¿ Ûÿ¿ Ûı¿ Û˘¿ Û˙¿ ÙK¿ Ùë¿ Ùï¿ Ùñ¿ Ù”¿ ı¿ ı	¿ ı
¿ ı4¿ ıL¿ ıP¿ ıQ¿ ı}¿ ıû¿ ı¢¿ ı£¿ ı»¿ ı‚¿ ıÊ¿ ıÁ¿ ˆ/¿ ˆb¿ ˆä¿ ˆé¿ ˆè¿ ˆ«¿ ˆÙ¿ ˆ¯¿ ˆ˘¿ ˜ ¿ ˜<¿ ˜@¿ ˜A¿ ˜Ö¿ ˜≈¿ ˜„¿ ˜Á¿ ˜Ë¿ ¯+¿ ¯^¿ ¯•¿ ¯ ¿ ¯Œ¿ ¯œ¿ ˘¿ ˘¿ ˘-¿ ˘F¿ ˘Y¿ ˘ß¿ ˘œ¿ ˘”¿ ˘‘¿ ˘Î¿ ˙¿ ˙'¿ ˙+¿ ˙,¿ ˙y¿ ˙†¿ ˙æ¿ ˙¬¿ ˙√¿ ˚¿ ˚T¿ ˚ó¿ ˚ò¿ ˚„¿ ¸¿ ¸8¿ ¸<¿ ¸=¿ ¸o¿ ¸∂¿ ¸’¿ ¸Ÿ¿ ¸⁄¿ ˝'¿ ˝j¿ ˝ü¿ ˝æ¿ ˝¬¿ ˝√¿ ˝ÿ¿ ˝˘¿ ˛¿ ˛¿ ˛¿ ˛a¿ ˛á¿ ˛•¿ ˛©¿ ˛™¿ ˛–¿ ˇ¿ ˇV¿ ˇá¿ ˇ∞¿ ˇ¥¿ ˇµ¿  ¿ .¿ T¿ X¿ Y¿ ®¿ Œ¿ ˇ¿%¿)¿*¿z¿§¿™¿˜¿H¿ó¿„¿&¿h¿É¿∂¿◊¿€¿‹¿,¿V¿\¿©¿˙¿I¿ï¿ÿ¿¿5¿f¿á¿ã¿å¿ÿ¿¿g¿ã¿ß¿Î¿
¿¿¿`¿£¿∏¿È¿	¿	6¿	Q¿	U¿	V¿	}¿	ô¿	ù¿	û¿	Â¿
¿

¿
¿
0¿
y¿
°¿
•¿
¶¿
˜¿
¯¿¿$¿?¿\¿|¿ñ¿Æ¿∆¿‚¿Ê¿Á¿¿¿Y¿¿É¿Ñ¿ ¿Í¿Ó¿Ô¿,¿^¿b¿c¿ï¿º¿¿¿¡¿¿^¿å¿Ø¿≥¿¥¿¿!¿%¿&¿]¿^¿í¿…¿Õ¿Œ¿Ú¿/¿V¿Z¿[¿ì¿¿¿ƒ¿≈¿Ì¿
¿¿¿Q¿é¿«¿˚¿ˇ¿ ¿I¿t¿u¿∞¿Õ¿¿<¿@¿A¿|¿ô¿›¿¿3¿7¿8¿Ü¿”¿¿i¿à¿ƒ¿≈¿¿\¿©¿ı¿.¿Q¿û¿∫¿¿¿¿S¿£¿È¿¿3¿u¿y¿z¿Ü¿¢¿È¿"¿&¿'¿v¿≈¿¿_¿ù¿–¿‘¿’¿¯¿¿¿¿c¿¨¿⁄¿ ¿H¿ô¿Œ¿¿%¿o¿≠¿˛¿¿Q¿R¿°¿È¿ 0¿ ~¿ ´¿ ¨¿ ˙¿!F¿!L¿!ô¿!„¿!¯¿"*¿"`¿"ï¿"ô¿"ö¿"È¿#¿#¿#_¿#ê¿#ø¿#‚¿#Ê¿#Ë    UnescapeErrorListenerListener [